grammar org.ddmore.mdl.Mdl with org.eclipse.xtext.common.Terminals
generate mdl "http://www.ddmore.org/mdl/Mdl"


Mcl hidden(WS, ML_COMMENT, SL_COMMENT):
	objects+=MclObject*;

MclObject:
	modelObject=ModelObject | 
	parameterObject=ParameterObject | 
	dataObject=DataObject | 
	taskObject=TaskObject |
	telObject=TELObject;
	
ModelObject:
	identifier=ObjectName '=' 'mdlobj' BEGIN blocks += ModelObjectBlock* END;
ParameterObject:
	identifier=ObjectName '=' 'parobj' BEGIN blocks += ParameterObjectBlock* END;
	
DataObject:
	identifier=ObjectName '=' 'dataobj' BEGIN blocks += DataObjectBlock* END;

TaskObject:
	identifier=ObjectName '=' 'taskobj' BEGIN blocks += TaskObjectBlock* END;
	
TELObject:
	identifier=ObjectName '=' 'telobj' BEGIN statements += BlockStatement* END;
	
//////////////////////////////////////////////////////////
//Model Object
//////////////////////////////////////////////////////////

ModelObjectBlock: 
	individualVariablesBlock = IndividualVariablesBlock | 
	modelPredictionBlock = ModelPredictionBlock |
	randomVariableDefinitionBlock = RandomVariableDefinitionBlock |
	inputVariablesBlock = InputVariablesBlock |
	structuralParametersBlock = StructuralParametersBlock |
	variabilityParametersBlock = VariabilityParametersBlock |
	outputVariablesBlock = OutputVariablesBlock |
	groupVariablesBlock = GroupVariablesBlock | 
	observationBlock = ObservationBlock |
	estimationBlock = EstimationBlock |
	simulationBlock = SimulationBlock |
	targetBlock = TargetBlock |
	importBlock = ImportBlock
;

IndividualVariablesBlock:
	identifier = 'INDIVIDUAL_VARIABLES' 
	BEGIN statements += BlockStatement* END  //new Variable +
;

ModelPredictionBlock:
	identifier = 'MODEL_PREDICTION' 
	BEGIN statements += ModelPredictionBlockStatement* END
;

RandomVariableDefinitionBlock:
	identifier = 'RANDOM_VARIABLE_DEFINITION' 
	BEGIN variables += SymbolDeclaration* END //new Variable +
;

InputVariablesBlock:
  	indentifier = 'INPUT_VARIABLES' 
  	BEGIN variables += SymbolDeclaration* END //new Variable +
;

StructuralParametersBlock:
  identifier = 'STRUCTURAL_PARAMETERS' 
  BEGIN parameters += FullyQualifiedSymbolName* END  //Ref to Parameter +
; 

VariabilityParametersBlock:
  identifier = 'VARIABILITY_PARAMETERS' 
  BEGIN parameters += FullyQualifiedSymbolName* END //Ref to Parameter +
;

OutputVariablesBlock:
	identifier = 'OUTPUT_VARIABLES' 
	BEGIN variables += FullyQualifiedSymbolName* END //Ref to VariableName +
; 

GroupVariablesBlock:
	identifier = 'GROUP_VARIABLES' 
	BEGIN statements += GroupVariablesBlockStatement* END
;

ObservationBlock:
	identifier = 'OBSERVATION'
	BEGIN statements += BlockStatement* END  //new Variable +
;

EstimationBlock:
	identifier = 'ESTIMATION' 
	BEGIN statements += BlockStatement* END  //new Variable +
;

SimulationBlock:
	identifier = 'SIMULATION' 
	BEGIN statements += BlockStatement* END  //new Variable +
;

//////////////////////////////////////////////////////////
//Parameter Object
//////////////////////////////////////////////////////////

ParameterObjectBlock:
	structuralBlock = StructuralBlock |
	variabilityBlock = VariabilityBlock |
	priorBlock = PriorParametersBlock |
	targetBlock = TargetBlock |
	importBlock = ImportBlock
;

StructuralBlock:
	identifier='STRUCTURAL'   
	BEGIN parameters += ParameterDeclaration* END //new Parameter +
;

VariabilityBlock:
	identifier='VARIABILITY' 
	BEGIN statements += VariabilityBlockStatement* END
;

PriorParametersBlock:
	identifier='PRIOR_PARAMETERS' 
	BEGIN statements += BlockStatement* END  //new Parameter +
;

//////////////////////////////////////////////////////////
//Data Object
//////////////////////////////////////////////////////////

DataObjectBlock:
	headerBlock = HeaderBlock |
	fileBlock = FileBlock |
	targetBlock = TargetBlock | 
	importBlock = ImportBlock;
 
HeaderBlock:
 	identifier='HEADER' 
 	BEGIN variables += SymbolModification* END  //ref to Variable
 ;
 
 FileBlock:
	identifier='FILE' 	
	BEGIN statements += FileBlockStatement* END
 ;
 
//////////////////////////////////////////////////////////
//Task Object
//////////////////////////////////////////////////////////
 
TaskObjectBlock: 
	functionDeclaration = TaskFunctionDeclaration | 
	parameterBlock = ParameterBlock |
	dataBlock = DataBlock |
	modelBlock = ModelBlock | 
	targetBlock = TargetBlock |
	importBlock = ImportBlock	
	;

ParameterBlock:
	identifier = 'PARAMETER' 
	BEGIN parameters += SymbolModification* END  //Ref to parameter
;

DataBlock:
	identifier = 'DATA' 
	BEGIN statements += DataBlockStatement* END
;

DataBlockStatement:
	ignoreList = IgnoreList | acceptList = AcceptList | dropList = DropList
;

IgnoreList:
	identifier = 'IGNORE' "=" 'if' '(' expression = OrExpression ')'
;

AcceptList:
	identifier = 'ACCEPT' "=" 'if' '(' expression = AndExpression ')'
; 

DropList:
	identifier = 'DROP' "=" list = SymbolList
;

ModelBlock:
	identifier = 'MODEL' 
	BEGIN statements += ModelBlockStatement* END
;

ModelBlockStatement:
	statement = BlockStatement |
	addList = AddList |
	removeList = RemoveList
;

AddList:
	'ADD' '=' list = SymbolList
;

RemoveList:
	'REMOVE' '=' list = SymbolList
;

SymbolList:
	'list' '(' symbols += FullyQualifiedSymbolName (=> ',' symbols += FullyQualifiedSymbolName+ ')')
;

ModelPredictionBlockStatement: 
	statement = BlockStatement | //new Variable
	odeBlock = OdeBlock | 
	libraryBlock = LibraryBlock
;

LibraryBlock: 
	identifier = 'LIBRARY' 
	BEGIN statements += FunctionCallStatement * END //Properties: format restricted to a "variable = function call"
;

FunctionCallStatement:
	identifier = ID "=" expression = FunctionCall
;

OdeBlock:
	identifier = 'ODE' 
	BEGIN statements += BlockStatement* END  //new Variable
;

GroupVariablesBlockStatement:
	statement = BlockStatement |  //new Variable
	mixtureBlock = MixtureBlock 
;

MixtureBlock:
	identifier = 'MIXTURE' 
	BEGIN statements += BlockStatement* END //new Variable
;


VariabilityBlockStatement:
	parameter = ParameterDeclaration | 
	blockBlock = BlockBlock | 
	diagBlock = DiagBlock	|
	sameBlock = SameBlock
;

//Renamed to Matrix!
BlockBlock:
	 identifier = 'matrix' '(' arguments = Arguments ')'
	 (BEGIN parameters = Arguments END)?  //new Parameter
;

DiagBlock:	  
	 identifier = 'diag' '(' arguments = Arguments ')'
	 (BEGIN parameters = Arguments END)?  //new Parameter
;

SameBlock:	  
	 identifier = 'same' '(' arguments = Arguments ')'
	 (BEGIN parameters = FormalArguments END)?  //new Parameter
;

//////////////////////////////////////////////////////////
//Data Object
//////////////////////////////////////////////////////////

FileBlockStatement:
	variable = SymbolDeclaration |  //new VariableName which can be only list
	inlineBlock = InlineBlock | 
	designBlock = DesignBlock | 
	rscriptBlock = RScriptBlock 
;

InlineBlock:
	identifier = 'INLINE' 
	BEGIN (variables += FullyQualifiedSymbolName)* (values += (NUMBER | '.'))* END //Ref to VaraibleName
;

DesignBlock:
	identifier = 'DESIGN' 
	BEGIN statements += DesignBlockStatement* END
;

DesignBlockStatement:
	identifier = FullyQualifiedSymbolName (arguments = VariableList)? '=' expression = AnyExpression  //Ref to VaraibleName
;

VariableList:
	'[' identifiers += FullyQualifiedSymbolName (=> ',' identifiers += FullyQualifiedSymbolName)* ']' //Ref to VaraibleName
;
	
RScriptBlock:	
	identifier = 'RSCRIPT' 
	BEGIN variables += RScriptBlockStatement* END	  			
;

RScriptBlockStatement:
	identifier = ID "=" (value = STRING | object = ObjectName) // new VariableName
;

TaskFunctionDeclaration:
	identifier = ID "=" 'function'   //new FunctionName
	'(' formalArguments = FormalArguments ')'
	functionBody = TaskFunctionBody
;

TaskFunctionBody: {TaskFunctionBody}	
	BEGIN	(blocks += TaskFunctionBlock)* END
;

TaskFunctionBlock:
	estimateBlock = EstimateTask |
	simulateBlock = SimulateTask |
	executeBlock = ExecuteTask
;

EstimateTask: 
	identifier = 'ESTIMATE' 
	BEGIN statements += BlockStatement* END //Properties
;

SimulateTask:
	identifier = 'SIMULATE' 
	BEGIN statements += BlockStatement* END  //Properties
;

ExecuteTask:
	identifier = "EXECUTE"
	BEGIN statements += BlockStatement* END  //Properties
;

//////////////////////////////////////////////////////////
//Common
//////////////////////////////////////////////////////////

FormalArguments:
	arguments += FormalArgument (=> ',' arguments += FormalArgument)*
;

FormalArgument:
	identifier = ID
;

FunctionCall:
	identifier = FullyQualifiedSymbolName '(' arguments = Arguments ')'
;

BlockStatement:
	symbol = SymbolDeclaration | //VariableName or PropertyName
	functionCall = FunctionCall |
	statement = ConditionalStatement |
	targetBlock = TargetBlock
;

TargetBlock: 
	identifier = 'TARGET_CODE' ('(' arguments = Arguments ')' )? BEGIN  externalCode = EXTERNAL_CODE END
;

TargetLanguage:
	'NMTRAN_CODE' | 'MLXTRAN_CODE' | 'PML_CODE' | 'BUGS_CODE' | 'R_CODE' | 'MATLAB_CODE' 	
;

terminal EXTERNAL_CODE: 
	'***' -> '***'
; 

ImportBlock:
	identifier = 'IMPORT' BEGIN 
		functions += ImportedFunction
	END //rename to functions
;

ImportedFunction:
	identifier = ID ("=" list = List) 
;

SymbolModification:
	identifier = FullyQualifiedSymbolName ("=" list = List)?  //Ref to ParameterName
;

ParameterDeclaration:
	identifier = ID ("=" list = List) //new ParameterName
;

//new VariableName, new PropertyName
SymbolDeclaration:
	(identifier = ID (("=" expression = AnyExpression)? | randomList = RandomList)) | 
	(function = ID '(' identifier = ID ')' randomList = RandomList)
	//special function, new VariableName
;

EnumType:
	categorical = Categorical | 
	continuous = Continuous | 
	covariate = Covariate |
	distribution = Distribution |
	level = LevelType |
	likelyhood = Likelyhood |
	missing = Missing |
	target = TargetLanguage
;

Missing:
	identifier = 'MISSING'
;

Likelyhood:
	identifier = 'LIKELIHOOD'	
;

LevelType:
	mdv = 'mdv' | 
	id = 'id' |
	dv = 'dv' |
	idv = 'idv' //Independent Variable
;

Categorical:
	identifier = 'categorical' ('(' arguments = Arguments ')')?
;

Continuous:
	identifier = 'continuous'
;

Covariate:
	identifier = 'covariate'
;

Distribution: 
	normal = 'Normal' |
	binomial = 'Binomial' |
	poisson = 'Poisson' |
	student_t = 'Student_T' |
	mvnormal = 'MVNormal' 
;

AnyExpression:
	expression = Expression | 
	list = List | 
	odeList = OdeList | 
	type = EnumType
;

Expression:
	conditionalExpression = ConditionalExpression 
;	

List:
	'list' '(' arguments = Arguments ')'
;

OdeList:
	 'ode' '(' arguments = Arguments ')' 
;

RandomList:
	 '~' '(' arguments = Arguments ')'
;

Arguments: 
	arguments += Argument (=> ',' arguments += Argument)*
;

Argument:
	identifier = ID "=" expression = AnyExpression |
	expression = AnyExpression
;

ConditionalStatement:
	'if' parExpression=ParExpression 
		(ifStatement = BlockStatement | ifBlock = Block)
	(=> 'else' 
		(elseStatement = BlockStatement | elseBlock = Block)
	)? 
;

Block: {Block}
	BEGIN statements += BlockStatement* END
;

ParExpression:
	'(' expression = Expression')';
	
ConditionalExpression:
	expression = OrExpression ('?' expression1 = Expression ':' expression2 = Expression)?;

OrExpression:
	expression += AndExpression (operator += LogicalOrOperator expression += AndExpression)*;

AndExpression:
	expression += LogicalExpression (operator += LogicalAndOperator expression += LogicalExpression)*;	

LogicalExpression:
	(negation = "!")? (boolean = BOOLEAN | 
	expression += AdditiveExpression (operator += LogicalOperator expression += AdditiveExpression)*);

AdditiveExpression:
	expression += MultiplicativeExpression (operator += AdditiveOperator expression+=MultiplicativeExpression)* |
	string += STRING (operator += AdditiveOperator string += STRING)*
;

MultiplicativeExpression:
	expression += PowerExpression (operator += MultiplicativeOperator expression += PowerExpression)*;

PowerExpression:
	expression += UnaryExpression (operator += PowerOperator expression += UnaryExpression)*;

UnaryExpression:
	operator = UnaryOperator expression = UnaryExpression |  
	parExpression = ParExpression |
	primary = Primary
	;

Primary:
	functionCall = FunctionCall |
	number = NUMBER |
	symbol = FullyQualifiedSymbolName |
	attribute = FullyQualifiedArgumentName |
	vector = Vector
;

Vector:
	identifier = 'c' '(' values += Expression (=> ',' values += Expression)* ')'
;	

FullyQualifiedSymbolName:
	(object = [ObjectName] '$')? identifier = ID //ref VariableName, ParameterName or FunctionName
;

FullyQualifiedArgumentName:
	parent = FullyQualifiedSymbolName selectors += Selector+  //ref ArgumentName
;

Selector:
	('.' identifier = ID ) | ('[' selector = NUMBER ']')
;

ObjectName:
	name = ID
;

LogicalAndOperator: '&&'
;		

LogicalOrOperator: '||'
;

LogicalOperator:
	'<' | '>' | "<=" | ">=" | '==' | '!=';

PowerOperator:
	'^'
;

MultiplicativeOperator:
	'*' | '/' | '%'  
;	

AdditiveOperator:
	'+' | '-'
;

UnaryOperator:
	'+' | '-' 
;

NUMBER:
	INTEGER | FLOAT; 
	
terminal STRING:
	'"' (ESCAPE_SEQUENCE | !('\\' | '"'))* '"';

terminal fragment ESCAPE_SEQUENCE:
	'\\' ('b' | 't' | 'n' | 'f' | 'r' | '\"' | '\'' | '\\')
	| UNICODE_ESCAPE
	| OCTAL_ESCAPE;

terminal fragment OCTAL_ESCAPE:
	  '\\' ('0'..'3') ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7');

terminal fragment UNICODE_ESCAPE:
	'\\' 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT;

terminal fragment HEXDIGIT:
	('0'..'9' | 'a'..'f' | 'A'..'F');
	
terminal BOOLEAN:
    'true' | 'false';		
	
terminal INTEGER:
	('0' | '1'..'9' '0'..'9'*);
	
terminal FLOAT
    : '0'..'9' + '.' '0'..'9'* EXPONENT?
    | '.' '0'..'9'+ EXPONENT?
    | '0'..'9'+ EXPONENT
    | ('0'..'9')
    ;

terminal fragment EXPONENT
	: ('e'|'E'|'d'|'D') ('+'|'-')?('0'..'9')+;

terminal SL_COMMENT : ('#') !('\n'|'\r')* ('\r'? '\n')? ;

terminal ML_COMMENT : '/#' -> '#/';

terminal BEGIN: '{';

terminal END: '}' ;