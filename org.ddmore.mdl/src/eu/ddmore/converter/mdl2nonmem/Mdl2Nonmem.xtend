/*
 * MDL converter toolbox
 * @DDMoRe
 * Author: Natallia Kokash, LIACS, 2012
 */
package eu.ddmore.converter.mdl2nonmem

import eu.ddmore.converter.mdlprinting.MdlPrinter
import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import org.ddmore.mdl.mdl.AndExpression
import org.ddmore.mdl.mdl.Arguments
import org.ddmore.mdl.mdl.DataObject
import org.ddmore.mdl.mdl.DiagBlock
import org.ddmore.mdl.mdl.EstimateTask
import org.ddmore.mdl.mdl.FullyQualifiedArgumentName
import org.ddmore.mdl.mdl.FunctionCall
import org.ddmore.mdl.mdl.List
import org.ddmore.mdl.mdl.LogicalExpression
import org.ddmore.mdl.mdl.MatrixBlock
import org.ddmore.mdl.mdl.Mcl
import org.ddmore.mdl.mdl.MixtureBlock
import org.ddmore.mdl.mdl.ModelObject
import org.ddmore.mdl.mdl.ModelPredictionBlock
import org.ddmore.mdl.mdl.OrExpression
import org.ddmore.mdl.mdl.ParameterObject
import org.ddmore.mdl.mdl.SameBlock
import org.ddmore.mdl.mdl.Selector
import org.ddmore.mdl.mdl.SimulateTask
import org.ddmore.mdl.mdl.SymbolDeclaration
import org.ddmore.mdl.mdl.TargetBlock
import org.ddmore.mdl.mdl.TaskObject
import org.ddmore.mdl.mdl.TaskObjectBlock
import org.ddmore.mdl.types.VariableType
import org.ddmore.mdl.validation.AttributeValidator
import org.ddmore.mdl.validation.FunctionValidator
import org.eclipse.emf.ecore.EObject
import org.ddmore.mdl.validation.DistributionValidator
import org.ddmore.mdl.validation.PropertyValidator
import org.ddmore.mdl.mdl.PropertyDeclaration
import org.ddmore.mdl.mdl.TargetType
import java.util.logging.Logger
import org.ddmore.mdl.mdl.AnyExpression
import org.ddmore.mdl.mdl.ConditionalExpression

class Mdl2Nonmem extends MdlPrinter {
    private static val Logger logger = Logger::getLogger("Mdl2Nonmem");
	
	protected var Mcl mcl = null;
	protected val var_random_base = "TMPR";
	
    private static val Mdl2Nonmem mdlPrinter = new Mdl2Nonmem();
    protected new(){}
    override static Mdl2Nonmem getInstance(){
        return mdlPrinter;
    }
	
	//Print file name and analyse MCL objects in the source file
  	def convertToNMTRAN(Mcl m){
  	    logger.info("In MDL2NONMEM converter");
  	    
  		mcl = m;
  		m.prepareCollections();  		 		
  			
  		var java.util.List<DataObject> dataObjects = new ArrayList<DataObject>
  		var java.util.List<TaskObject> taskObjects = new ArrayList<TaskObject>
  		
        for (o:m.objects) {
            if (o.dataObject != null)
                dataObjects.add(o.dataObject);
            if (o.taskObject != null)
                taskObjects.add(o.taskObject);
        }
		var nm = 
		'''
		;generated by MDL2NMTRAN v.«mdlVersion»
		«printSIZES»
		«printPROB»
		«FOR d:dataObjects»
			«d.printINPUT(taskObjects)»
			«d.printDATA»
	  	«ENDFOR»
		«FOR t:taskObjects»
			«t.printIGNORE»
	  	«ENDFOR»
		«FOR o:m.objects»
			«IF o.parameterObject != null»
				«o.parameterObject.convertToNMTRAN»
			«ENDIF»
	  	«ENDFOR»
		«FOR o:m.objects»
			«IF o.modelObject != null»
				«o.modelObject.convertToNMTRAN»
			«ENDIF»
	  	«ENDFOR»
		«FOR o:m.objects»
			«IF o.taskObject != null»
				«o.taskObject.convertToNMTRAN»
			«ENDIF»
		«ENDFOR»
		''';
		nm = nm.replaceAll("(\r\n|\n)(?=#DEL#)", "");
		nm = nm.replace("#DEL#", "");
		return nm;
	}
	
////////////////////////////////////	
//convertToNonmem MCL
////////////////////////////////////
	//Print NM-TRAN record $SIZES
	def printSIZES()'''
	«IF "$SIZ".isTargetDefined»
	
	«getExternalCodeStart("$SIZ")»
	«getExternalCodeEnd("$SIZ")»
	«ENDIF»	
	'''

	//Print NM-TRAN record $PROB/$PROBLEM
	def printPROB()'''
	«IF "$PRO".isTargetDefined»
	
	«getExternalCodeStart("$PRO")»
	«getExternalCodeEnd("$PRO")»
	«ELSE»
	
	$PROB «mcl.fileName.toUpperCase»
	«ENDIF»
	'''

	//Print NM-TRAN record $ABB/$ABBREVIATED
	def printABBREVIATED()'''
	«IF "$ABB".isTargetDefined»

	«getExternalCodeStart("$ABB")»
	«getExternalCodeEnd("$ABB")»
	«ENDIF»
	'''
	
	//Print NM-TRAN record $AES
	def printAES()'''
	«IF "$AES".isTargetDefined»
	
	«getExternalCodeStart("$AES")»
	«getExternalCodeEnd("$AES")»
	«ENDIF»
	'''

////////////////////////////////////	
//convertToNonmem Model Object
////////////////////////////////////	
	def convertToNMTRAN(ModelObject o){
		val contentPK = o.printPKContent;
		val isLibraryDefined = o.isLibraryDefined;
		val contentError = o.printErrorContent;
		val contentDES = o.printDESContent;
		val contentMODEL = o.printMODELContent;
		val contentMIX = o.printMIXContent;
		
		'''
		«o.printSUBR»
		«contentMODEL.printMODEL»
		«o.generateMODEL»
		«printABBREVIATED»
		«IF isLibraryDefined»

			«contentPK.printPK»
			«contentDES.printDES»
			«printAES»
			«contentMIX.printMIX»
			«contentError.printERROR»
		«ELSE» 
				
			$PRED
			«getExternalCodeStart("$PRE")»
			«contentPK»
			«contentMIX»
			«contentError»
			«getExternalCodeEnd("$PRE")»
			«contentDES.printDES»
			«printAES»
		«ENDIF»
		«o.printTABLE»
		'''
	}

	//Print NM-TRAN  record $PK
	def printPK(CharSequence contentPK)'''
	«IF contentPK.length > 0»
	
	$PK
	«ENDIF»
	«getExternalCodeStart("$PK")»
	«contentPK»
	«getExternalCodeEnd("$PK")»
	'''
	
	//Processing GROUP_VARIABLES, INDIVIDUAL_VARIABLES, MODEL_PREDICTION (init conditions) for $PK
	def printPKContent(ModelObject o)'''
	«FOR b:o.blocks»
		«IF	b.groupVariablesBlock != null»
			«FOR st: b.groupVariablesBlock.statements»
				«IF st.variable != null»
					«st.variable.print»
				«ENDIF»
			«ENDFOR»
		«ENDIF»
		«IF b.individualVariablesBlock != null»
			«FOR s: b.individualVariablesBlock.variables SEPARATOR ' '»
				«s.print»
			«ENDFOR»
		«ENDIF»
		«IF b.modelPredictionBlock != null»	
			«b.modelPredictionBlock.printPKContent»	
		«ENDIF»
	«ENDFOR»
	«IF init_vars.entrySet.size > 0»

			;initial conditions
			«FOR e: init_vars.entrySet»
				A_0(«e.key») = «e.value»
			«ENDFOR»
	«ENDIF»	
	'''
	
	//include the content of MODEL_PREDICTION before LIBRARY to $PK
	def printPKContent(ModelPredictionBlock b){
		var res  = "";
		var include = true;
		for (s: b.statements){
			if (s.libraryBlock != null) include = false;
			if (s.variable != null && include){
				if (s.variable != null && s.variable.argumentName != null && s.variable.expression != null){
					if (s.variable.argumentName.parent.name.equals("A")){
						res = res + '''
							A_0«s.variable.argumentName.selectors.get(0).toStr» = «s.variable.expression.toStr»
						'''
					}
				} else {
					res  = res + '''«s.variable.print»''';
				}
			}
		}
		return res;
	}
	
	//Print NM-TRAN record $MIX 
	def printMIX(CharSequence contentMIX)'''
	«IF contentMIX.length > 0»
		
		$MIX
	«ENDIF»
	«getExternalCodeStart("$MIX")»
	«contentMIX»
	«getExternalCodeEnd("$MIX")»
	'''

	def printMIXContent(ModelObject o)'''
	«FOR b:o.blocks»
		«IF	b.groupVariablesBlock != null»
			«FOR st: b.groupVariablesBlock.statements»
				«IF st.mixtureBlock != null»
					«st.mixtureBlock.print»
				«ENDIF»
			«ENDFOR»
		«ENDIF»
	«ENDFOR»
	'''
	
	//Print block
	def print(MixtureBlock b){
		var nspop = 0;
		for (st: b.variables){
			if (st.list != null){
				nspop = st.list.arguments.arguments.size;
			}
		}		
		var res = "";
		if (nspop > 0){
			res  = "NSPOP = " + nspop + "\n";
			var i = 1;
			for (st: b.variables){
				if (st.expression != null){
					res = res + "P(" + i + ") = " + st.expression.toStr + "\n";
					i = i + 1;
				}
			}		
		}
		'''«res»'''
	}
	
	//Print NM-TRAN record $ERROR
	def printERROR(CharSequence contentError)'''
	«IF contentError.length > 0»	
	
	$ERROR
	«ENDIF»
	«getExternalCodeStart("$ERR")»
	«contentError»
	«getExternalCodeEnd("$ERR")»
	'''	
	
	//Processing MODEL_PREDICTION, OBSERVATION for $ERROR
	def printErrorContent(ModelObject o)'''
		«FOR mob:o.blocks»
			«IF mob.modelPredictionBlock != null»
				«mob.modelPredictionBlock.printErrorContent»
			«ENDIF»
			«IF mob.observationBlock != null»
				«mob.observationBlock.print»
			«ENDIF»
			«IF mob.simulationBlock != null»
				«mob.simulationBlock.print»
			«ENDIF»
			«IF mob.estimationBlock != null»
				«mob.estimationBlock.print»
			«ENDIF»			
		«ENDFOR»
	'''
	
	//include the content of MODEL_PREDICTION after LIBRARY to $ERROR
	def printErrorContent(ModelPredictionBlock b){
		var res  = "";
		var include = false;
		for (s: b.statements){
			if (s.libraryBlock != null) include = true;
			if (s.variable != null && include){
				if (s.variable.argumentName != null){
					//skip init values (vector field assignments)
				} else {
					res  = res + '''«s.variable.print»''';
				}
			}
		}
		return res;
	}
	
	//If there is a definition with ncmt=N, define N compartment names
	def generateMODEL(ModelObject o){
		var res = "";
		var nmct =  o.numberOfCompartments;		
		if (nmct > 0) {
			res = res + "\n$MODEL\n";
			for (i : 1 ..nmct) {
 			   res = res + "COMP (comp" + i + ")\n"
			}
		}
		'''«res»'''
	}

	//Processing MODEL_PREDICTION for $MODEL
	def printMODEL(CharSequence contentMODEL)'''
	«IF contentMODEL.length > 0»
	
	$MODEL
	«ENDIF»
	«getExternalCodeStart("$MOD")»
	«contentMODEL»
	«getExternalCodeEnd("$MOD")»
	'''
	
	def printMODELContent(ModelObject o)'''
		«FOR b:o.blocks»
			«IF b.modelPredictionBlock != null»
				«var bb = b.modelPredictionBlock»
				«FOR s: bb.statements»
					«IF s.odeBlock != null»
						«FOR ss: s.odeBlock.variables»
							«IF ss.symbolName != null && ss.list!= null»
								COMP(«ss.symbolName.name»)
							«ENDIF»
						«ENDFOR»
					«ENDIF»
				«ENDFOR»
			«ENDIF»
		«ENDFOR»
	'''

	//Processing MODEL_PREDICTION for $DES
	def printDES(CharSequence contentDES)'''
	«IF contentDES.length > 0»

	$DES
	«ENDIF»
	«getExternalCodeStart("$DES")»
	«contentDES»
	«getExternalCodeEnd("$DES")»
	'''    
    
    def printDESContent(ModelObject o)'''
	    «FOR b:o.blocks»
			«IF b.modelPredictionBlock != null»
				«var bb = b.modelPredictionBlock»
				«FOR s: bb.statements»
					«IF s.odeBlock != null»
						«FOR ss: s.odeBlock.variables»
							«IF ss.expression != null»
								«ss.print»
							«ENDIF»
							«IF ss.list != null»
								«var deriv = ss.list.arguments.getAttribute(AttributeValidator::attr_req_deriv.name)»
								«IF deriv.length > 0 && ss.symbolName != null»
									«var id = ss.symbolName.name»
									«IF dadt_vars.get(id) != null»
										DADT(«dadt_vars.get(id)») = «deriv»
									«ENDIF»	
								«ENDIF»
							«ENDIF»
						«ENDFOR»
					«ENDIF»
				«ENDFOR»
			«ENDIF»
		«ENDFOR»
    '''
    
	//Processing MODEL_PREDICTION for $SUBR
	def printSUBR(ModelObject o)'''
	«getExternalCodeStart("$SUB")»
	«FOR b:o.blocks»
		«IF b.modelPredictionBlock != null»
			«b.modelPredictionBlock.printSUBR»
		«ENDIF»
	«ENDFOR»
	«getExternalCodeEnd("$SUB")»
    ''' 
    
    //Processing MODEL_PREDICTION for $SUBR
    //Find an imported function name and attributes "model", "trans"
	def printSUBR(ModelPredictionBlock b){
		var res  = "";
		for (ss: b.statements){
			if (ss.libraryBlock != null){
				for (st: ss.libraryBlock.statements){
					var library = st.expression.identifier.name;
					if (library.equals(FunctionValidator::lib_nmadvan))
						library = "ADVAN";
					val model = st.expression.arguments.getAttribute(FunctionValidator::param_nmadvan_model.name);
					val trans = st.expression.arguments.getAttribute(FunctionValidator::param_nmadvan_trans.name);
					val tol = getTOL;
					res = res + '''«IF model.length > 0»«library.toUpperCase()»«model»«ENDIF» «IF trans.length > 0»TRANS«trans»«ENDIF» «IF tol.length > 0»TOL = «tol»«ENDIF»'''
				}
			}
		}
		if (res.length > 0)
			return 
			'''
			$SUBR «res»
			'''
	}
		
	//Print NM-TRAN record $TABLE
	def printTABLE(ModelObject o){
		val contentTABLE = o.printTABLEContent;
		'''
			«IF contentTABLE.length > 0»
			
			$TABLE 
			«ENDIF»	
			«getExternalCodeStart("$TAB")»
			«contentTABLE»
			«getExternalCodeEnd("$TAB")»
		'''
	}
	
	def printTABLEContent(ModelObject o)'''
		«FOR b:o.blocks»
			«IF b.outputVariablesBlock != null»
				«var bb = b.outputVariablesBlock»
				«IF bb.variables.size > 0»
					«FOR st: bb.variables SEPARATOR ' '»«st.name.convertID»«ENDFOR»
					«val file = getTaskObjectName»
					ONEHEADER NOPRINT «IF file.length > 0»FILE=«file».fit«ENDIF» 
				«ENDIF»
			«ENDIF»	
		«ENDFOR»
	'''
 
////////////////////////////////////
//convertToNonmem PARAMETER OBJECT
/////////////////////////////////////		
	def convertToNMTRAN(ParameterObject o){
		o.collectDimensionsForSame;	
		val contentPRIOR = o.printPRIORContent;
		val contentTHETA = o.printTHETAContent;
		'''
		«contentTHETA.printTHETA»
		«o.printOMEGA»
		«o.printSIGMA»
		«contentPRIOR.printPRIOR»
		'''
	}

	//Copy statements from PRIOR block to $PRIOR
	def printPRIOR(CharSequence contentPrior)'''
	«IF contentPrior.length > 0»
	
	$PRIOR
	«ENDIF»	
	«getExternalCodeStart("$PRI")»
	«contentPrior»
	«getExternalCodeEnd("$PRI")»
	'''
	
	def printPRIORContent(ParameterObject o)'''
		«FOR b:o.blocks»			
			«IF b.priorBlock != null»
				«FOR st: b.priorBlock.parameters»
					«st.print»
				«ENDFOR»
			«ENDIF»
		«ENDFOR»
	'''
		
	//Processing STRUCTURAL for $THETA
	def printTHETA(CharSequence contentTHETA)'''
	«IF contentTHETA.length > 0»

	$THETA
	«ENDIF»
	«getExternalCodeStart("$THE")»
	«contentTHETA»
	«getExternalCodeEnd("$THE")»
	'''
	
	def printTHETAContent(ParameterObject o)'''
	«FOR b:o.blocks»			
		«IF b.structuralBlock != null»
			«FOR st: b.structuralBlock.parameters»
				«st.printTheta»
			«ENDFOR»
		«ENDIF»
	«ENDFOR»
	'''
	
	//Processing VARIABILITY for $OMEGA
	def printOMEGA(ParameterObject o)'''
	«externalCodeStart.get("$OME")»
	«o.printVariabilityBlock("$OMEGA")»
	«externalCodeEnd.get("$OME")»
	'''
	
	//Processing VARIABILITY for $SIGMA
	def printSIGMA(ParameterObject o)'''
	«getExternalCodeStart("$SIG")»
	«o.printVariabilityBlock("$SIGMA")»
	«getExternalCodeEnd("$SIG")»
	'''
	
	//Return VARIABILITY block statements for $SIGMA or $OMEGA
	def printVariabilityBlock(ParameterObject o, String section){
		var res = "";
		for (b:o.blocks){
			if (b.variabilityBlock != null){
				var printSectionName = true;
				for (c: b.variabilityBlock.statements){
					if (c.parameter != null){
						var tmp = c.parameter.printVariabilityParameter(section);
						if (tmp.length > 0){
							if (printSectionName){
								res = res + "\n" + section + "\n";
								printSectionName = false;
							}
							res = res + tmp;
						}
					}
					if (c.diagBlock != null){
						res  = res + c.diagBlock.printDiag(section);
						printSectionName = true;
					}
					if (c.matrixBlock != null){
						res  = res + c.matrixBlock.printMatrix(section);
						printSectionName = true;
					}
					if (c.sameBlock != null){
						res  = res + c.sameBlock.printSame(section);
						printSectionName = true;
					}
				}
			}
		}
		return res;
	}
	
	//$OMEGA BLOCK(dim) SAME ; varName
	//$SIGMA BLOCK(dim) SAME ; varName
	def printSame(SameBlock b, String section) { 
		var name = b.arguments.getAttribute(AttributeValidator::attr_name.name);
		if (name.length == 0) return '''''';
		val isOmega = section.equals("$OMEGA") && (namedOmegaBlocks.get(name) != null);
		val isSigma = section.equals("$SIGMA") && (namedSigmaBlocks.get(name) != null);
		if (isOmega || isSigma)	{			
			var k = 0;
			if (isOmega) k = namedOmegaBlocks.get(name);
			if (isSigma) k = namedSigmaBlocks.get(name);
			return 
			'''
			
			«section» «IF k > 0»BLOCK («k») SAME«ENDIF»
			«IF b.parameters != null»
				«FOR p: b.parameters.symbolNames»
					; «p.name»
				«ENDFOR»
			«ENDIF»
			'''
		}
		return "";
	}	
	
	//Create maps with dimensions for same blocks
	def collectDimensionsForSame(ParameterObject obj){
		for (b:obj.blocks){
			if (b.variabilityBlock != null){
				for (c: b.variabilityBlock.statements){
					if (c.diagBlock != null)
						c.diagBlock.collectDimensionsForSame;
					if (c.matrixBlock != null)
						c.matrixBlock.collectDimensionsForSame;
				}
			}
		}
	}
	
	//Create maps with dimensions for same blocks corresponding to diag(...){...}
	def collectDimensionsForSame(DiagBlock b){
		var k = 0; 
		var name = b.arguments.getAttribute(AttributeValidator::attr_name.name);
		var isOmega = false;
		var isSigma = false;
		if (name != null){
			if (b.parameters != null)		
				for (p: b.parameters.arguments) {
					if (p.expression != null){
						k = k + 1;
						if (p.argumentName != null){
							if (p.argumentName.name.isOmega) isOmega = true;
							if (p.argumentName.name.isSigma) isSigma = true;
						} 
					}
				}		
			if (isOmega) namedOmegaBlocks.put(name, k);
			if (isSigma) namedSigmaBlocks.put(name, k);
		}
	}
	
	def isOmega(String varName){
		for (o: mcl.objects){
			if (o.modelObject != null){
				for (b: o.modelObject.blocks){
		  			if (b.randomVariableDefinitionBlock != null){
						for (s: b.randomVariableDefinitionBlock.variables) {
							if (s.randomList != null){	
								var id = s.randomList.arguments.getAttribute(DistributionValidator::attr_var.name);
								if (id.length == 0)
									id = s.randomList.arguments.getAttribute(DistributionValidator::attr_sd.name);
								if (id.equals(varName)) 
									if (s.symbolName != null && eta_vars.get(s.symbolName.name) != null) return true;
							}
						}
					}
				}
			}
		}
		//For distributions other than normal (no var or sd parameters), link name (XXX and eta_XXX) 
		if (eps_vars.get("eta_" + varName) != null) return true;		
		return false;
	}
	
	def isSigma(String varName){
		for (o: mcl.objects){
			if (o.modelObject != null){
				for (b: o.modelObject.blocks){
		  			if (b.randomVariableDefinitionBlock != null){
						for (s: b.randomVariableDefinitionBlock.variables) {
							if (s.randomList != null){	
								var id = getAttribute(s.randomList.arguments, DistributionValidator::attr_var.name);
								if (id.length == 0)
									id = getAttribute(s.randomList.arguments, DistributionValidator::attr_sd.name);
								if (id.equals(varName)) 
									if (s.symbolName != null && eps_vars.get(s.symbolName.name) != null) return true;
							}
						}
					}
				}
			}
		}
		//For distributions other than normal (no "var" or "sd" attributes), link name (XXX and eps_XXX) 
		if (eps_vars.get("eps_" + varName) != null) return true;
		return false;
	}
	
	//Create maps with dimensions for same blocks corresponding to matrix(...){...}
	def collectDimensionsForSame(MatrixBlock b){
		var k = 0;
		var name = getAttribute(b.arguments, AttributeValidator::attr_name.name);
		var isOmega = false;
		var isSigma = false;
		if (b.parameters != null)
			for (p: b.parameters.arguments) {
				if (p.expression != null){
					if (p.argumentName != null){
						if (p.argumentName.name.isOmega) isOmega = true;
						if (p.argumentName.name.isSigma) isSigma = true;
						k = k + 1;
					}
				}
			}
		if (isOmega) namedOmegaBlocks.put(name, k);
		if (isSigma) namedSigmaBlocks.put(name, k);
	}

	//Print diag(...){...} subblock of VARIABILITY
	def printDiag(DiagBlock b, String section){
		var result = "";
		var printFix = false;
		var k = 0; 
		for (a: b.arguments.arguments){
			if (a.argumentName != null){ 
				if (a.argumentName.name.equals(AttributeValidator::attr_fix.name)){ 
					if (a.expression != null){
						printFix = a.expression.isTrue	
					}
				}				
			}
		}	
		if (b.parameters != null)		
			for (p: b.parameters.arguments) {
				if (p.expression != null){
					var  i = 0;
					var tmpRes = "";
					while (i < k){
						tmpRes = tmpRes + "0 ";
						i = i + 1;
					}
					k = k + 1;
					if (p.argumentName != null){
						val isOmega = section.equals("$OMEGA") && p.argumentName.name.isOmega;
						val isSigma = section.equals("$SIGMA") && p.argumentName.name.isSigma;
						if (isOmega || isSigma)	{
							result = result + tmpRes + p.expression.toStr + " ";
							result = result + "; " + p.argumentName.name + "\n";
						}
					} 
					else
						if (result.length > 0) result = result + p.expression.toStr + " ";
				}
			}		
		if (printFix && result.length > 0) result = result + "FIX\n";
		if (result.length == 0) return "";		
		return
		'''
		
		«section» «IF k > 0»BLOCK («k») «ENDIF»
		«result»
		'''
	}
	
	//Print matrix(...){...} subblock of VARIABILITY
	def printMatrix(MatrixBlock b, String section)
	{
		var result = "";
		var printFix = false;
		var k = 0; 
		for (a: b.arguments.arguments){
			if (a.argumentName != null){ 
				if (a.argumentName.name.equals(AttributeValidator::attr_fix.name)) 
					if (a.expression != null){
						printFix = a.expression.isTrue		
					}
			}
		}
		if (b.parameters != null)
			for (p: b.parameters.arguments) {
				if (p.expression != null){
					if (p.argumentName != null){
						val isOmega = section.equals("$OMEGA") && p.argumentName.name.isOmega;
						val isSigma = section.equals("$SIGMA") && p.argumentName.name.isSigma;
						if (isOmega || isSigma)	{
							result = result + p.expression.toStr + " ";
							result = result + "; " + p.argumentName.name + "\n";
							k = k + 1;
						}
					} 
					else
						if (result.length > 0) result = result + p.expression.toStr + " ";
				}
			}
		if (printFix && result.length > 0) result = result + "FIX\n";
		if (result.length == 0) return "";
		return 
		'''
		
		«section» «IF k > 0»BLOCK («k») «ENDIF»
		«result»
		'''; 
	}	

	//Print VARIABILITY parameter in $SIGMA or $OMEGA
	def printVariabilityParameter(SymbolDeclaration s, String section){
		if (s.symbolName != null){
			var name = s.symbolName.name;
			//SIGMA <=> EPS, OMEGA <=> ETA	
			var isOmega = section.equals("$OMEGA") && name.isOmega;
			var isSigma = section.equals("$SIGMA") && name.isSigma;
			if (isOmega || isSigma){
				if (s.list != null){
					val value = s.list.arguments.getAttribute(AttributeValidator::attr_req_value.name);
					val printFix = s.list.arguments.isAttributeTrue(AttributeValidator::attr_fix.name);
					return							
					'''
					«IF value.length > 0»«value»«IF printFix» FIX«ENDIF»«ENDIF» ; «name»
					'''
				} else {
					if (s.expression != null){
						val value = s.expression.toStr;
						return'''«value» ; «name»'''
					}
				}
			}
		}
		return "";
	}
	
	
	//Find attributes in STRUCTURAL_VARIABLES and form an NMTRAN statement
	def printTheta(SymbolDeclaration s){
		if (s.symbolName != null){
			var name = s.symbolName.name;
			if (s.list != null){		
				val args = s.list.arguments;
				val value = args.getAttribute(AttributeValidator::attr_value.name);
				val lo = args.getAttribute(AttributeValidator::attr_lo.name);
				val hi = args.getAttribute(AttributeValidator::attr_hi.name);
				val printFix = args.isAttributeTrue(AttributeValidator::attr_fix.name);
				if (value.length == 0) return "";
				if (lo.length == 0 && hi.length == 0) return '''«value»«IF printFix» FIX«ENDIF» ; «name»'''
				if (lo.length == 0) return '''(-INF, «value», «hi»)«IF printFix» FIX«ENDIF» ; «name»'''
				if (hi.length == 0) return '''(«lo», «value», INF)«IF printFix» FIX«ENDIF» ; «name»'''
				return '''(«lo», «value», «hi»)«IF printFix» FIX«ENDIF» ; «name»'''
			} else {
				if (s.expression != null) {
					return '''«s.expression.toStr» ; «name»'''
				}
			}
		}
	}	
	
////////////////////////////////////	
//convertToNonmem DATA OBJECT
////////////////////////////////////
	//Print NM-TRAN record $INPUT
	def printINPUT(DataObject d, java.util.List<TaskObject> t){
		val contentINPUT = d.printINPUTContent(t);
		'''
		«IF contentINPUT.length > 0»
			
		$INPUT
		«ENDIF»
		«getExternalCodeStart("$INP")»
		«FOR b:d.blocks»
		    «IF b.dataInputBlock != null»
				«FOR st: b.dataInputBlock.variables SEPARATOR ' '»«IF st.symbolName != null»«IF isDrop(st.symbolName.name, t)»«st.symbolName.name»=DROP«ELSE»«st.symbolName.name»«ENDIF»«ENDIF»«ENDFOR»
	        «ENDIF»
		«ENDFOR»
		«getExternalCodeEnd("$INP")»
		'''
	}
	
	def printINPUTContent(DataObject d, java.util.List<TaskObject> t)'''
		«FOR b:d.blocks»
		    «IF b.dataInputBlock != null»
				«FOR st: b.dataInputBlock.variables SEPARATOR ' '»«IF st.symbolName != null»«IF isDrop(st.symbolName.name, t)»«st.symbolName.name»=DROP«ELSE»«st.symbolName.name»«ENDIF»«ENDIF»«ENDFOR»
	        «ENDIF»
		«ENDFOR»
	'''
	
	//Note: We drop now all the variables in the specification regardless of the object they refer to
    def isDrop(String id, java.util.List<TaskObject> t) {
        for (TaskObject tObj :t) {
            for (b: tObj.blocks) {
                if (b.dataBlock !=  null) {
                    for (s: b.dataBlock.statements) {
                        if (s.propertyName != null) {
                            if (s.propertyName.equals(PropertyValidator::attr_data_drop.name)){
	                            if (s.expression != null){
	                            	if (s.expression.vector != null){
	                            		for (value : s.expression.vector.values) {
	                            			if (value.symbol != null){
	                            				if (id.equals(value.symbol.name))
			                                    	return true;
	                            			}
	                            		}
	                            	}
	                            }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
	
	//Print NM-TRAN record $DATA
	// Note that the double quotes are stripped off the file name; this is because whilst
	// NONMEM can handle this (to allow spaces in the file name), PsN can not.
	// The Ignore char may have the same problem so strip the quotes off this too.
	def printDATA(DataObject o)'''
	«FOR b:o.blocks»
		«IF b.sourceBlock != null»
			«var data = ""»
			«var ignore = ""»
			«FOR s: b.sourceBlock.statements»
				«IF s.propertyName.name.equals(PropertyValidator::attr_file.name) && s.expression != null»
					«data = stripQuotes(s.expression.toStr)»
				«ENDIF»	
				«IF s.propertyName.name.equals(PropertyValidator::attr_ignore.name) && s.expression != null»
					«ignore = stripQuotes(s.expression.toStr)»
				«ENDIF»	
			«ENDFOR»
			«IF data.length > 0»
								
				$DATA «data»
				«getExternalCodeStart("$DAT")»
				«IF ignore.length > 0»IGNORE=«ignore»«ENDIF»
				«getExternalCodeEnd("$DAT")»
			«ENDIF»
		«ENDIF»
	«ENDFOR»
	'''
	
	
/////////////////////////////////////////////////
//convertToNonmem TASK OBJECT
/////////////////////////////////////////////////

	//Processing task object for $EST and $SIM
	def convertToNMTRAN(TaskObject o)'''
	«FOR b:o.blocks»
		«IF b.estimateBlock != null»
			«b.estimateBlock.print»
		«ENDIF»
		«IF b.simulateBlock != null»
			«b.simulateBlock.print»
		«ENDIF»
	«ENDFOR»
	'''
	
	//Print NM-TRAN IGNORE=... statements
	def printIGNORE(TaskObject o)'''
	«FOR b: o.blocks»
		«IF b.dataBlock !=  null»
			«FOR st: b.dataBlock.statements»
				«IF st.propertyName != null && st.expression != null»
					«IF st.propertyName.name.equals(PropertyValidator::attr_data_ignore.name)»
						«IF st.expression.expression != null»
							IGNORE («st.expression.expression.expression.toCommaSeparatedStr»)
						«ENDIF»
					«ENDIF»	
				«ENDIF»
			«ENDFOR»
		«ENDIF»
	«ENDFOR»
	''' 
	
	//Processing SIMULATE block for $SIM 
	def print(SimulateTask b)'''
		«IF !"$SIM".isTargetDefined»

		$SIM 
			«FOR s: b.statements»
				«s.printDefaultSimulate»
			«ENDFOR»
		«ELSE»
			«getExternalCodeStart("$SIM")»
			«getExternalCodeEnd("$SIM")»
		«ENDIF» 
	'''
	
	//Processing ESTIMATE block for $EST
	def print(EstimateTask b)'''
		«IF !"$EST".isTargetDefined»

		$EST 
			«FOR s: b.statements»
				«IF s != null»«s.printDefaultEstimate»«ENDIF»
			«ENDFOR»
			NOABORT 
			«b.printCovariance»
		«ELSE»
			«getExternalCodeStart("$EST")»
			«getExternalCodeEnd("$EST")»
		«ENDIF»
	'''
	
	def isInline(TargetBlock b){
		var target = "";
		var location = "";
		for (p: b.statements){
			if (p.propertyName.name.equals(PropertyValidator::attr_req_target.name))
				target = p.expression.toStr;
			if (p.propertyName.name.equals(PropertyValidator::attr_location.name))
				location = p.expression.toStr;
		}
		if (target.equals(TargetType::NMTRAN_CODE.toString)) 
			return (location.length == 0 || location.equals("INLINE")); 
		return false;
	}
	
	def isSameline(TargetBlock b){
		var target = "";
		var AnyExpression sameline = null;
		for (p: b.statements){
			if (p.propertyName.name.equals(PropertyValidator::attr_req_target.name))
				target = p.expression.toStr;
			if (p.propertyName.name.equals(PropertyValidator::attr_sameline.name))
				sameline = p.expression;
		}
			if (target.equals(TargetType::NMTRAN_CODE.toString) || sameline != null) {
				return sameline.isTrue;
			}
		return false;
	}
		
	//Print attributes for default $EST record
	def printDefaultEstimate(PropertyDeclaration s) { 
		if (s.propertyName != null){
			if (s.propertyName.name.equals(PropertyValidator::attr_task_algo.name)){
				var value = "";
				if (s.expression.expression != null)
					value = s.expression.expression.toStr
				else {
					if (s.expression.list != null){
						var args = s.expression.list.arguments;
						if (args != null)
							if (args.arguments.size > 0)
								value = args.arguments.get(0).expression.toStr;
					} 
				}
				if (value.length > 0) {
				    // Strip off any enclosing double quotes around the string first
				    val algo = stripQuotes(value.convertAlgo);
					'''METHOD=«algo»'''
				}
			}
			else
				if (s.propertyName.name.equals(PropertyValidator::attr_task_max.name))
				    ''' MAX=«s.expression.print»'''
			else
				if (s.propertyName.name.equals(PropertyValidator::attr_task_sig.name))
				    ''' SIG=«s.expression.print»'''
		}
	}
	
	def convertAlgo(String str){
		if (str.contains("FOCE "))
			return str.replace("FOCE ", "CONDITIONAL ");
		if (str.contains("FO "))
		 	return str.replace("FO ", "ZERO ");
		if (str.contains("SAEM") || str.contains ("IMP") || str.contains("BAYES")){
			return str + " AUTO = 1";
		}
	}
	
	//Print attributes for default $SIM record
	def printDefaultSimulate(PropertyDeclaration s)'''
	'''
	
	//Print $COV 
	def printCovariance(EstimateTask b){
		var covariance = "";
		for (st: b.statements) {
			if (st.propertyName != null && 
				st.propertyName.name.equals(PropertyValidator::attr_task_cov.name))
					if (st.expression != null) covariance = st.expression.toStr;
		}
		'''
		«IF covariance.length > 0»
		
		$COV 
		«ENDIF»
		«getExternalCodeStart("$COV")»
		«covariance»
		«getExternalCodeEnd("$COV")»
		'''	
	}
	
	//Get task object name 
	def getTaskObjectName(){
		for (obj: mcl.objects){
  			if (obj.taskObject != null)
  				return obj.objectName.name;
  		}
		return "";
	}
	
	//Get $TOL attribute
	def getTOL(){
		for (obj: mcl.objects){
  			if (obj.taskObject != null){
  				val tol = obj.taskObject.getTOL;
				if (tol.length > 0) return tol;
  			}
  		}
		return "";
	}
	
	//Get $TOL attribute
	def getTOL(TaskObject obj){
		for (TaskObjectBlock b: obj.blocks){
			if (b.modelBlock != null){
				for (ss: b.modelBlock.statements){
					if (ss.propertyName != null){
						if (ss.propertyName.name.equalsIgnoreCase(PropertyValidator::attr_model_tolrel.name)){
							if (ss.expression != null)
								return ss.expression.toStr;
						}
					}
				}
			}
		}
		return "";
	}	
	
	protected var externalCodeStart = new HashMap<String, ArrayList<String>>() //external code per target language section,
	protected var externalCodeEnd = new HashMap<String, ArrayList<String>>() //external code per target language section,
 	
	protected var theta_vars = newHashMap //THETAs - Structural parameters
	protected var dadt_vars = newHashMap  //DADT   - Model prediction -> ODE	
	protected var init_vars = newHashMap  //A      - Model prediction -> ODE -> init attribute	
	
	protected var eps_vars = newHashMap   //EPSs   - Random variables, level 1
	protected var eta_vars = newHashMap	  //ETAs   - Random variables, level 2
	
	protected var level_vars = newHashMap //       - Input variables, level attribute			
	
	//These maps are used to print same blocks (NM-TRAN SAME opetion in $OMEGA and $SIGMA)
	protected var namedOmegaBlocks = new HashMap<String, Integer>() //Collection of names of $OMEGA records with dimensions
	protected var namedSigmaBlocks = new HashMap<String, Integer>() //Collection of names of $SIGMA records with dimensions
	
	protected var binomial_vars = new HashSet<String>();	
	
 	def protected clearCollections(){
		init_vars.clear;
		dadt_vars.clear;
		theta_vars.clear;
		eta_vars.clear;
    	eps_vars.clear; 
    	namedOmegaBlocks.clear;
    	namedSigmaBlocks.clear;	
    	eta_vars.clear;
    	eps_vars.clear; 
    	binomial_vars.clear;
	}
	
	//Collect variables from the MDL file
	def protected prepareCollections(Mcl m){
    	clearCollections();
    	for (o:m.objects){
	  		if (o.modelObject != null){
	  			setLevelVars(o.modelObject);
	  			setRandomVariables(o.modelObject);
	  			setStructuralParameters(o.modelObject);
	  			setModelPredictionVariables(o.modelObject);
	  			setInitialConditions(o.modelObject);
	  		} 
  		}
  		m.prepareExternals;
  		m.prepareBinomialVars;
	}	
	
	def addToBinomial(EObject x){
		if (x instanceof SymbolDeclaration){
			var s = x as SymbolDeclaration;
			if (s.symbolName != null && s.list != null){
				var type = s.list.arguments.getAttribute(AttributeValidator::attr_type.name);
				if (type.equals(VariableType::CC_LIKELIHOOD))
					if (!binomial_vars.contains(s.symbolName.name)){
						binomial_vars.add(s.symbolName.name);
						System::out.println("Binomial variable was added: " + s.symbolName.name);	
					}
			}		
		}
	}
	
	def removeFromBinomial(EObject x){
		if (x instanceof SymbolDeclaration){
			var s = x as SymbolDeclaration;
			if (s.symbolName != null && s.list != null){
				if (binomial_vars.contains(s.symbolName.name)){
					var type = s.list.arguments.getAttribute(AttributeValidator::attr_type.name);
					if (!type.equals(VariableType::CC_LIKELIHOOD)){
						binomial_vars.remove(s.symbolName.name);
						System::out.println("Binomial variable was removed: " + s.symbolName.name);	
					}
				}
			}		
		}
	}
	
	def prepareBinomialVars(Mcl m){
	  	for (o:m.objects){
			var subTree = mcl.eAllContents;
			subTree.forEach[addToBinomial]; 
			var subTree2 = mcl.eAllContents;
			subTree2.forEach[removeFromBinomial]; 
		}
	}
	
	def setLevelVars(ModelObject o){
		var tmp = o.getLevelVars("1");
		for (v: tmp){
			if (level_vars.get(v) == null)
				level_vars.put(v, "1");
		}
		tmp = o.getLevelVars("2");
		for (v: tmp){
			if (level_vars.get(v) == null)
				level_vars.put(v, "2");
		}
	}
		
	def protected getLevelVars(ModelObject o, String levelId) {
		var levelVars = new HashSet<String>();
		for (b: o.blocks){
			if(b.inputVariablesBlock != null){
				for (s: b.inputVariablesBlock.variables){
					if (s.list != null) {
						var level = s.list.arguments.getAttribute(AttributeValidator::attr_level.name);
						if (level.equals(levelId)){
							if (s.symbolName != null){
								if (!levelVars.contains(s.symbolName.name)){
									levelVars.add(s.symbolName.name);
								}
							}
						}
					}
				}
			}
		}
		return levelVars;
	}	
		
	//Assign indices to variability parameters ($ETA, $ESP)
	def protected setRandomVariables(ModelObject o){
    	var i = 1; var j = 1; 
		for (b: o.blocks){
	  		if (b.randomVariableDefinitionBlock != null){
				for (s: b.randomVariableDefinitionBlock.variables) {
					if (s.randomList != null && s.symbolName != null){	
						var level = s.randomList.arguments.getAttribute(AttributeValidator::attr_level.name);
						val	id = s.symbolName.name;
						if (level_vars.get(level) != null){
							if (level_vars.get(level).equals("2")){
								if (eta_vars.get(id) == null){
									eta_vars.put(id, i);
									i = i + 1;
								}
							}
							if (level_vars.get(level).equals("1"))
								if (eps_vars.get(id) == null){
									eps_vars.put(id, j);
									j = j + 1;
								}	
							}
						}
	  			}
	  		}
  		}
	}
	
	
	//Collect initial conditions from ODE list, init attribute
	def protected setInitialConditions(ModelObject o){
		var i = 1;
		for (b:o.blocks){
			if (b.modelPredictionBlock != null)
				for (s: b.modelPredictionBlock.statements){
					if (s.odeBlock != null)
						for (ss: s.odeBlock.variables){
							if (ss.list != null){
								val initCond = ss.list.arguments.getAttribute(AttributeValidator::attr_init.name);
								if (initCond.length > 0){
									init_vars.put(i, initCond);
								} else init_vars.put(i, "0");
								i = i + 1;
							}
						}
				}
		}
	}
	
	//Assign indices to MODEL variables and expressions
	def protected setModelPredictionVariables(ModelObject o) { 
		var i = 1;
		for (b:o.blocks){
			if (b.modelPredictionBlock != null){
				for (s: b.modelPredictionBlock.statements){
					if (s.odeBlock != null){
						for (ss: s.odeBlock.variables){
							if (ss.list != null && ss.symbolName != null){
								var id = ss.symbolName.name;
								if (dadt_vars.get(id) == null){
									dadt_vars.put(id, i);
									i = i + 1;
								}
							}
						}
					}
				}
			}
		}
	}

	//Assign indices to THETAs
	def protected setStructuralParameters(ModelObject o){
    	var i = 1; 
		for (b: o.blocks){
	  		if (b.structuralParametersBlock != null){
				for (id: b.structuralParametersBlock.parameters) {
					if (id.symbolName != null){
						if (theta_vars.get(id.symbolName.name) == null){
							theta_vars.put(id.symbolName.name, i);
							i = i + 1;
						}
					}
				}
	  		}	  				
  		}
	}
	
	//Find NM-TRAN functions
	def protected prepareExternals(Mcl mcl) {
		externalCodeStart.clear;	
		externalCodeEnd.clear;
		var subTree = mcl.eAllContents;
		while (subTree.hasNext()){
			var x = subTree.next();
			if (x instanceof TargetBlock){
				var block = x as TargetBlock;
				block.prepareExternalCode;
			}
		}
	}
	
	//Prepare a map of section with corresponding target blocks
	def void prepareExternalCode(TargetBlock b){
		var target  = "";
		var location = "";
		var AnyExpression last = null;
		for (p: b.statements){
			if (p.propertyName.name.equals(PropertyValidator::attr_req_target.name))
				target = p.expression.toStr;
			if (p.propertyName.name.equals(PropertyValidator::attr_location.name))
				location = p.expression.toStr;
			if (p.propertyName.name.equals(PropertyValidator::attr_last.name))
				last = p.expression;
		}
		if (target.equals(TargetType::NMTRAN_CODE.toString) && location.length() > 0) {
			location = stripQuotes(location.toStr) // Strip off any enclosing double quotes (if present)
			location = location.substring(0, Math::min(4, location.length())) // And truncate to 4 characters
			if (last != null && last.isTrue){
				var codeSnippets = externalCodeEnd.get(location);
				if (codeSnippets == null) codeSnippets = new ArrayList<String>();
				codeSnippets.add(b.toStr);
				externalCodeEnd.put(location, codeSnippets);
			} 
			else {
				var codeSnippets = externalCodeStart.get(location);
				if (codeSnippets == null) codeSnippets = new ArrayList<String>();
				codeSnippets.add(b.toStr);
				externalCodeStart.put(location, codeSnippets);
			}
		}
	}	

 	//Print a list of external code snippets: beginning of section
	def protected getExternalCodeStart(String sectionName){
		var res = "";		
		val snippets = externalCodeStart.get(sectionName) 
		if (snippets != null){
			for (x: snippets){
				if (x.startsWith("#DEL#"))
					res = res + x 
				else res = res + "\n" + x;
			}
		}
		return res;
	}
	
	//Print a list of external code snippets: end of section
	def protected getExternalCodeEnd(String sectionName){
		var res = "";		
		val snippets = externalCodeEnd.get(sectionName) 
		if (snippets != null){
			for (x: snippets)
				if (x.startsWith("#DEL#"))
					res = res + x 
				else res = res + "\n" + x;
		}
		return res;
	}
 
	def isTargetDefined(String sectionName){
		return externalCodeStart.containsKey(sectionName) || externalCodeEnd.containsKey(sectionName);
	}

    /**
     * Override the to-string from the MDL->PharmML printing functionality for a String
     * to enclose this string within double quotes for NONMEM.
     */	
    def toStr(String str) {
        return "\"" + str + "\""
    }
	
	//(==, !=, <, > etc.) - here we skip boolean values!
	override toStr(LogicalExpression e){
		if (e.boolean != null) 	return "";
		return super.toStr(e);
	}				
	
	//Used to keep track of temporal variables for the conversion of runif to RANDOM
	var runifCount = 0;
	
	//Print variableDeclaration substituting ID with "Y" if it is a list with likelihood or continuous type
	override toStr(SymbolDeclaration v){
		var res = "";
		if (v.expression != null){
			//preprint CALL RANDOM()
			runifCount = 0;
			var subTree = v.expression.eAllContents;
			while (subTree.hasNext()){
				var x = subTree.next();
				if (x instanceof FunctionCall){
					var call = x as FunctionCall;
					if (call != null){
						if (call.identifier.name.equals(FunctionValidator::funct_runif)){
							if (call.arguments != null && call.arguments.arguments.size() > 0){
								val arg = call.arguments.arguments.get(0);
								val param = arg.expression.toStr;
								res  = res + "CALL RANDOM(" + param +
								", R)\n" + var_random_base + runifCount + " = R\n";
								runifCount = runifCount + 1;
							} 
						}
					}
				}
			}
			if (v.symbolName != null && v.list != null){
				var type = v.list.arguments.getAttribute(AttributeValidator::attr_type.name);
				if (type.length() > 0){
					if (type.equals(VariableType::CC_CONTINUOUS)) 
						res = res + "F_FLAG = 0\n"; 
					if (type.equals(VariableType::CC_LIKELIHOOD) && !binomial_vars.contains(v.symbolName.name)) 
						res = res + "F_FLAG = 1\n";
					if (type.equals(VariableType::CC_M2LL)) 
						res = res + "F_FLAG = 2\n";		
					//substitute variable name with Y
					var listExpr  = v.list.toStr;
					if (listExpr.length > 0) return res + "Y = " + listExpr + "\n" 	
				}
			}			
		}
		return res + super.toStr(v);
	}
		
	//Instead of list(...) we print an expression from a certain attribute (depends on the type)
	override toStr(List l){		
		var res = "";
		var type = l.arguments.getAttribute(AttributeValidator::attr_type.name);
		if (type.equals(VariableType::CC_LIKELIHOOD)){
			res = l.arguments.getAttribute(AttributeValidator::attr_prediction.name);
		} else 
			if (type.equals(VariableType::CC_CONTINUOUS)){
				res = l.arguments.getAttribute(AttributeValidator::attr_prediction.name);
				var ruv = l.arguments.getAttribute(AttributeValidator::attr_ruv.name);
				if (ruv.length > 0)
					res = res + "+" + ruv
			}			
		return res;
	}
	
	//toStr function call
	override toStr(FunctionCall call){
		//if (call.identifier.name.equals(FunctionValidator::funct_errorExit))
		//	return "EXIT" + call.arguments.toStrWithoutCommas;
		//No control flow altering statements are allowed in MDL!
		if (call.identifier.name.equals(FunctionValidator::funct_runif)){
			if (call.arguments != null) {
				var container = call.eContainer()
				if (container instanceof SymbolDeclaration) {
					return "RANDOM CALL (" + call.arguments.arguments.get(0) +
						", " + var_random_base + ")\n";
				}
			}
			if (runifCount > 0){
				runifCount = runifCount - 1; 
				return var_random_base + runifCount;			
			}
		}
		if (call.identifier.name.equals(FunctionValidator::funct_pnorm))
			return "PHI" + "(" + call.arguments.toStr + ")";			
		return super.toStr(call);	
	}	
	
	
	//References to attributes: skip variable name and replace selectors, e.g,  amount.A[2] -> A(2)
	override toStr(FullyQualifiedArgumentName arg) { 
		var res = "";
		if (arg.selectors.get(0).argumentName == null)
			res = res + arg.parent.name;
		for (s: arg.selectors)
			res = res + s.toStr
		return res;
	}
	
	//Selectors [] -> (), e.g., A[2] -> A(2)
	override toStr(Selector s) { 
		if (s.argumentName != null)
			return s.argumentName.name;
		if (s.selector != null)
			return "(" + s.selector + ")";
	}	

		
	//Print list arguments without commas
	def toStrWithoutCommas(Arguments arg){
		var res  = "";
		var iterator = arg.arguments.iterator();
		while (iterator.hasNext){
			var a = iterator.next; 
			if (a.expression != null)
				res = res + " " + a.expression.toStr;
		}
		return res;
	}	
	
	//Convert variable names to NM-TRAN versions
	override convertID(String id){
		if (eta_vars.get(id) != null){
			return "ETA(" + eta_vars.get(id) + ")";
		}
		if (eps_vars.get(id) != null){
			return "EPS(" + eps_vars.get(id) + ")";
		}
		if (theta_vars.get(id) != null){
			return "THETA(" + theta_vars.get(id) + ")"; 
		}
		if (dadt_vars.get(id) != null){
			return "A(" + dadt_vars.get(id) + ")"; 
		}
		if (id.equalsIgnoreCase("ln")) return "LOG";
		if (id.equals("R")) return "myR";	
		return id.toUpperCase();	
	}	
	
	//Override MDL operators with NM-TRAN operators
	override convertOperator(String op){
		if (op.equals("<")) return ".LT.";
		if (op.equals(">")) return ".GT.";
		if (op.equals("<=")) return ".LE.";
		if (op.equals(">=")) return ".GE.";
		if (op.equals("==")) return ".EQ.";
		if (op.equals("!=")) return ".NE.";		
		if (op.equals("^")) return "**";
		if (op.equals("||")) return ".OR.";
		if (op.equals("&&")) return ".AND.";
		return op;	
	}
	
	//This is needed because of a bug in NONMEM x||y -> x, y for IGNORE statement
	//toStr OR expression
	def toCommaSeparatedStr(OrExpression e){
		var res = "";
		var iterator = e.expression.iterator();
		if (iterator.hasNext ) res = iterator.next.toStr;
		while (iterator.hasNext) res  = res + ', ' + iterator.next.toStr;	
		return res;
	}
	
	//This is needed because of a bug in NONMEM x&&y -> x, y for ACCEPT statement
	//toStr AND expression
	def toCommaSeparatedStr(AndExpression e){
		var res = "";
		var iterator = e.expression.iterator();
		if (iterator.hasNext ) res = iterator.next.toStr;
		while (iterator.hasNext)
			res  = res + ', ' + iterator.next.toStr;
		return res;	
	}

	override toStr(TargetBlock b){
		var target = "";
		for (p: b.statements){
			if (p.propertyName.name.equals(PropertyValidator::attr_req_target.name))
				target = p.expression.toStr;
		}
		if (target.equals(TargetType::NMTRAN_CODE.toString)) {
			if (b.isSameline) return "#DEL# " + super.toStr(b).trim;
			super.toStr(b);
		}
	}
		
	//Override statement printing to substitute MDL conditional operators with NM-TRAN operators
	override print(ConditionalExpression s)'''
		IF («s.condition.print») THEN
			«s.thenExpression.print»
		«IF s.elseExpression != null»
		ELSE 
			«s.elseExpression.print»
		«ENDIF»	
		ENDIF
	'''	
	
    //Check if LIBRARY block is defined
    def isLibraryDefined(ModelObject o){
    	for (mob: o.blocks){
			if (mob.modelPredictionBlock != null)
				for (s: mob.modelPredictionBlock.statements)
				    if (s.libraryBlock != null) return true;
    	}
    	return false;
    }
    
    //Check if LIBRARY block is defined
    def getNumberOfCompartments(ModelObject o){
    	for (mob: o.blocks){
			if (mob.modelPredictionBlock != null){
				for (s: mob.modelPredictionBlock.statements){
				    if (s.libraryBlock != null) {
				    	for (ss: s.libraryBlock.statements){
				    		var nmct = ss.expression.arguments.getAttribute(FunctionValidator::param_nmadvan_ncmt.name);
				    		if (nmct.length > 0) {
				    			try{
						    		return Integer::parseInt(nmct);
				    			}
				    			catch(NumberFormatException e){
				    				return 0;		
				    			}
				    		}
				    	}
				    }
				}
			}
    	}
    	return 0;
    }
    
    /**
     * Strip off any enclosing double quotes around a string.
     * This is primarily used when writing out to NMTRAN; NONMEM can usually (at least with recent
     * versions) handle strings in quotes (primarily data file and ignore char) but PsN cannot.
     * <p>
     * @param str - input string
     * @return output string with enclosing double quotes, if present, removed
     */
    def static String stripQuotes(String str) {
        return str.replaceAll("^\"(.+)\"$", "$1");
    }
	
}
