package eu.ddmore.converter.mdl2pharmml
import org.ddmore.mdl.mdl.Mcl
import eu.ddmore.converter.mdlprinting.MdlPrinter
import org.ddmore.mdl.validation.FunctionValidator
import java.util.ArrayList
import java.util.HashMap
import static extension eu.ddmore.converter.mdl2pharmml.Constants.*
import eu.ddmore.converter.mdl2pharmml.domain.Operation
import org.ddmore.mdl.validation.ModellingObjectGroup

class Mdl2PharmML{

	//Print file name and analyse all MCL objects in the source file
  	def convertToPharmML(Mcl m){
		val ReferenceResolver resolver = new ReferenceResolver(m, MdlPrinter::getInstance()); 
		val MathPrinter mathPrinter = new MathPrinter(resolver);
		val mdPrinter = new ModelDefinitionPrinter(mathPrinter, resolver);  		
		val msPrinter = new ModellingStepsPrinter(mathPrinter, resolver);  		
		val tdPrinter = new TrialDesignPrinter(mathPrinter, resolver); 
		
		var operations = new ArrayList<Operation>();
		var MOGs = new HashMap<String, ModellingObjectGroup>();

		//Note: when creating MOG, use the following order to pass object names:
		//	1 - model object
		//  2 - parameter object
		//  3 - data object
		//  4 - task object 
		for (o: m.objects){
			if (o.telObject != null){
				for (st: o.telObject.statements){
					val functionName = st.expression.identifier.function.name;
					if (st.expression.identifier.object != null){
						val tObjName = st.expression.identifier.object.name;
						val tObj = resolver.getTaskObject(tObjName);
						for (b: tObj.blocks){
							if (b.functionDeclaration != null){
								if (b.functionDeclaration.functionName.name.equals(functionName)){
									for (bb: b.functionDeclaration.functionBody.blocks){
										if ((bb.estimateBlock != null) || (bb.simulateBlock != null)){
											val modelParam = mathPrinter.getProperty(bb, FunctionValidator::attr_task_model.name); 
											val paramParam = mathPrinter.getProperty(bb, FunctionValidator::attr_task_parameter.name); 
											val dataParam = mathPrinter.getProperty(bb, FunctionValidator::attr_task_data.name); 
											if (dataParam.length > 0 && modelParam.length > 0 && paramParam.length > 0){
												val mObjName = mathPrinter.getAttribute(st.expression.arguments, modelParam);
												val dObjName = mathPrinter.getAttribute(st.expression.arguments, dataParam);
												val pObjName = mathPrinter.getAttribute(st.expression.arguments, paramParam);
												var stepType = BLK_ESTIM_STEP;
												val key = mObjName + "-" + dObjName + "-" + pObjName;	
												val mog = new ModellingObjectGroup(mObjName, pObjName, dObjName, tObjName);
												if (!MOGs.containsKey(key)) MOGs.put(key, mog);	
												if (bb.simulateBlock != null) stepType = BLK_SIMUL_STEP;
													operations.add(new Operation(functionName, stepType, mog));
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		'''
			<?xml version="1.0" encoding="UTF-8"?>
			<PharmML 
				«print_PharmML_NameSpaces»
				writtenVersion="«writtenVersion»">
				<ct:Name>"«mathPrinter.fileName(m)» - generated by MDL2PharmML v.«mathPrinter.mdlVersion»"</ct:Name>
				«FOR s: resolver.ind_vars»
					<IndependentVariable symbId="«s»"/>
				«ENDFOR»
				«FOR mog: MOGs.entrySet»
					«mdPrinter.print_mdef_ModelDefinition(mog.value.getModelObjName(), mog.value.getParamObjName())»
				«ENDFOR»
				«FOR op: operations»
					«msPrinter.print_msteps_ModellingSteps(op)»
				«ENDFOR»
				«FOR mog: MOGs.entrySet»
					«tdPrinter.print_design_TrialDesign(mog.value.getModelObjName(), mog.value.getParamObjName())»
				«ENDFOR»
			</PharmML>
		'''			
	}
	
	//+ Print PharmML namespaces
	protected def print_PharmML_NameSpaces()
		'''
		xmlns:xsi="«xsi»" 
		xmlns="«xmlns_pharmML»"
		xsi:schemaLocation="«xsi_schemaLocation»"
		xmlns:math="«xmlns_math»"
		xmlns:ct="«xmlns_ct»"
		xmlns:ds="«xmlns_ds»"
		xmlns:mdef="«xmlns_mdef»"
		xmlns:mstep="«xmlns_mstep»"
		xmlns:design="«xmlns_design»"
		'''
}