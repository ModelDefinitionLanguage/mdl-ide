package eu.ddmore.converter.mdl2pharmml
import org.ddmore.mdl.mdl.Mcl
import eu.ddmore.converter.mdlprinting.MdlPrinter
import org.ddmore.mdl.validation.FunctionValidator
import java.util.ArrayList
import java.util.HashMap
import static extension eu.ddmore.converter.mdl2pharmml.Constants.*
import eu.ddmore.converter.mdl2pharmml.domain.Operation
import org.ddmore.mdl.validation.ModellingObjectGroup

class Mdl2PharmML{

	//Print file name and analyse all MCL objects in the source file
  	def convertToPharmML(Mcl m){
		val ReferenceResolver resolver = new ReferenceResolver(m, MdlPrinter::getInstance()); 
		val MathPrinter mathPrinter = new MathPrinter(resolver);
		val mdPrinter = new ModelDefinitionPrinter(mathPrinter, resolver);  		
		val msPrinter = new ModellingStepsPrinter(mathPrinter, resolver);  		
		val tdPrinter = new TrialDesignPrinter(mathPrinter, resolver); 
		
		var operations = new ArrayList<Operation>();
		var MOGs = new HashMap<String, ModellingObjectGroup>();

		for (o: m.objects){
			if (o.telObject != null){
				for (st: o.telObject.statements){
					val functionName = st.expression.identifier.function.name;
					if (st.expression.identifier.object != null){
						val tObj = resolver.getTaskObject(st.expression.identifier.object.name);
						for (b: tObj.blocks){
							if (b.functionDeclaration != null){
								if (b.functionDeclaration.functionName.name.equals(functionName)){
									for (bb: b.functionDeclaration.functionBody.blocks){
										if ((bb.estimateBlock != null) || (bb.simulateBlock != null)){
											val modelParam = mathPrinter.getProperty(bb, FunctionValidator::attr_task_model.name); 
											val paramParam = mathPrinter.getProperty(bb, FunctionValidator::attr_task_parameter.name); 
											val dataParam = mathPrinter.getProperty(bb, FunctionValidator::attr_task_data.name); 
											if (dataParam.length > 0 && modelParam.length > 0 && paramParam.length > 0){
												val mObjName = mathPrinter.getAttribute(st.expression.arguments, modelParam);
												val dObjName = mathPrinter.getAttribute(st.expression.arguments, dataParam);
												val pObjName = mathPrinter.getAttribute(st.expression.arguments, paramParam);
												var stepType = BLK_ESTIM_STEP;
												if (bb.simulateBlock != null) stepType = BLK_SIMUL_STEP;
													operations.add(new Operation(
														functionName, stepType,
														mObjName, pObjName, dObjName
													));
												val key = mObjName + "-" + dObjName + "-" + pObjName;	
												if (!MOGs.containsKey(key))	
													MOGs.put(key, new ModellingObjectGroup(mObjName, dObjName, pObjName));	
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (MOGs.size == 0){
			//No TEL object or Task object, create MOG from 3 obejcts in the MCL file
			var mdlObjects = new ArrayList<String>();
			var paramObjects = new ArrayList<String>();
			var dataObjects = new ArrayList<String>();			
			for (o: m.objects){
				if (o.modelObject != null){				 
					mdlObjects.add(o.objectName.name);
				}
				if (o.parameterObject != null){				 
					paramObjects.add(o.objectName.name);
				}
				if (o.dataObject != null){				 
					dataObjects.add(o.objectName.name);
				}
			}
			for (mObjName: mdlObjects){
				for (pObjName: paramObjects){
					for (dObjName: dataObjects){
						val key = mObjName + "-" + dObjName + "-" + pObjName;	
						if (!MOGs.containsKey(key))	
							MOGs.put(key, new ModellingObjectGroup(mObjName, dObjName, pObjName));	
					}
				}
			}
		}
		
		'''
			<?xml version="1.0" encoding="UTF-8"?>
			<PharmML 
				«print_PharmML_NameSpaces»
				writtenVersion="«writtenVersion»">
				<ct:Name>"«mathPrinter.fileName(m)» - generated by MDL2PharmML v.«mathPrinter.mdlVersion»"</ct:Name>
				«FOR s: resolver.ind_vars»
					<IndependentVariable symbId="«s»"/>
				«ENDFOR»
				«FOR mog: MOGs.entrySet»
					«mdPrinter.print_mdef_ModelDefinition(mog.value.getMdlObjName(), mog.value.getParamObjName())»
				«ENDFOR»
				«FOR op: operations»
					«msPrinter.print_msteps_ModellingSteps(op)»
				«ENDFOR»
				«FOR mog: MOGs.entrySet»
					«tdPrinter.print_design_TrialDesign(mog.value.getMdlObjName(), mog.value.getParamObjName())»
				«ENDFOR»
			</PharmML>
		'''			
	}
	
	//+ Print PharmML namespaces
	protected def print_PharmML_NameSpaces()
		'''
		xmlns:xsi="«xsi»" 
		xmlns="«xmlns_pharmML»"
		xsi:schemaLocation="«xsi_schemaLocation»"
		xmlns:math="«xmlns_math»"
		xmlns:ct="«xmlns_ct»"
		xmlns:ds="«xmlns_ds»"
		xmlns:mdef="«xmlns_mdef»"
		xmlns:mstep="«xmlns_mstep»"
		xmlns:design="«xmlns_design»"
		'''
}