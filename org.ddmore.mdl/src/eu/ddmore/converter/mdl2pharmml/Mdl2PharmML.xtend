package eu.ddmore.converter.mdl2pharmml
import org.ddmore.mdl.mdl.Mcl
import eu.ddmore.converter.mdlprinting.MdlPrinter
import java.util.ArrayList
import static extension eu.ddmore.converter.mdl2pharmml.Constants.*
import eu.ddmore.converter.mdl2pharmml.domain.Operation
import org.ddmore.mdl.mdl.TargetBlock
import org.ddmore.mdl.mdl.MclObject
import org.ddmore.mdl.types.DefaultValues
import org.ddmore.mdl.validation.Utils
import org.ddmore.mdl.mdl.impl.MclObjectImpl

class Mdl2PharmML{

	//Print file name and analyse all MCL objects in the source file
  	def convertToPharmML(Mcl m){
		val ReferenceResolver resolver = new ReferenceResolver(m, MdlPrinter::getInstance()); 
		val MathPrinter mathPrinter = new MathPrinter(resolver);
		val mdPrinter = new ModelDefinitionPrinter(mathPrinter, resolver);  		
		val msPrinter = new ModellingStepsPrinter(mathPrinter, resolver);  		
		val tdPrinter = new TrialDesignPrinter(mathPrinter, resolver); 
		
		var operations = new ArrayList<Operation>();
		var mogs = Utils::getMOGs(m);
		
		for (mog: mogs){
			for (o: mog.objects){
				var container = o.eContainer;
				if (container instanceof MclObjectImpl){
					val mclObject = container as MclObject;
					if (mclObject.taskObject != null){
						//Found a task object
						for (b: mclObject.taskObject.blocks){
							if ((b.estimateBlock != null) || (b.simulateBlock != null)){
								var stepType = BLK_ESTIM_STEP;
								if (b.simulateBlock != null) stepType = BLK_SIMUL_STEP;
								operations.add(new Operation(o.name, stepType, mog));
							}
						}
					}
				}
			}
		}
		'''
			<?xml version="1.0" encoding="UTF-8"?>
			<PharmML 
				«print_PharmML_NameSpaces»
				writtenVersion="«writtenVersion»">
				<ct:Name>"«mathPrinter.fileName(m)» - generated by MDL2PharmML v.«mathPrinter.mdlVersion»"</ct:Name>
				<IndependentVariable symbId="«DefaultValues::INDEPENDENT_VAR»"/>
				«FOR mog: mogs»
					«mdPrinter.print_mdef_ModelDefinition(mog)»
				«ENDFOR»
				«FOR op: operations»
					«msPrinter.print_msteps_ModellingSteps(op)»
				«ENDFOR»
				«FOR mog: mogs»
					«tdPrinter.print_design_TrialDesign(mog)»
				«ENDFOR»
			</PharmML>
		'''			
	}
	
	def extractTargetCode(Mcl mcl){
		var tcbIterator = mcl.eAllContents;
		var res = "";
	   	while (tcbIterator.hasNext) {
			var container = tcbIterator.next;
			if (container instanceof TargetBlock) {
				var s = container as TargetBlock;
				res  = res + s.extractExternalCode;
			}
		}
		return res;
	}
	
	def extractTargetCode(MclObject obj){
		var tcbIterator = obj.eAllContents;
		var res = "";
	   	while (tcbIterator.hasNext) {
			var container = tcbIterator.next;
			if (container instanceof TargetBlock) {
				var s = container as TargetBlock;
				res  = res + s.extractExternalCode;
			}
		}
		return res;
	}
	
	protected def extractExternalCode(TargetBlock s){
		val mdlPrinter = MdlPrinter::getInstance();
    	'''
			<targetBlock>
			«IF s.arguments != null»
				«FOR a: s.arguments.arguments»
					«IF a.argumentName != null»
						<«a.argumentName.name»>
							«mdlPrinter.toStr(a.expression)»
						</«a.argumentName.name»>
					«ENDIF»
			   	«ENDFOR»
		    «ENDIF»
				<code>
					«mdlPrinter.toStr(s)»
				</code>
			</targetBlock>	
    	'''
	}
	
	//+ Print PharmML namespaces
	protected def print_PharmML_NameSpaces()
		'''
		xmlns:xsi="«xsi»" 
		xmlns="«xmlns_pharmML»"
		xsi:schemaLocation="«xsi_schemaLocation»"
		xmlns:math="«xmlns_math»"
		xmlns:ct="«xmlns_ct»"
		xmlns:ds="«xmlns_ds»"
		xmlns:mdef="«xmlns_mdef»"
		xmlns:mstep="«xmlns_mstep»"
		xmlns:design="«xmlns_design»"
		'''
}