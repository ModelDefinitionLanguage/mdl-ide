package eu.ddmore.converter.mdl2pharmml
import org.ddmore.mdl.mdl.Mcl
import eu.ddmore.converter.mdlprinting.MdlPrinter
import java.util.ArrayList
import java.util.HashMap
import static extension eu.ddmore.converter.mdl2pharmml.Constants.*
import eu.ddmore.converter.mdl2pharmml.domain.Operation
import org.ddmore.mdl.validation.ModellingObjectGroup
import org.ddmore.mdl.mdl.TargetBlock
import org.ddmore.mdl.mdl.MclObject

class Mdl2PharmML{

	//Print file name and analyse all MCL objects in the source file
  	def convertToPharmML(Mcl m){
		val ReferenceResolver resolver = new ReferenceResolver(m, MdlPrinter::getInstance()); 
		val MathPrinter mathPrinter = new MathPrinter(resolver);
		val mdPrinter = new ModelDefinitionPrinter(mathPrinter, resolver);  		
		val msPrinter = new ModellingStepsPrinter(mathPrinter, resolver);  		
		val tdPrinter = new TrialDesignPrinter(mathPrinter, resolver); 
		
		var operations = new ArrayList<Operation>();
		var MOGs = new HashMap<String, ModellingObjectGroup>();

		var objects = new HashMap<String, MclObject>();
		for (o: m.objects){
			objects.put(o.objectName.name, o);	
		}
		for (o: m.objects){
			if (o.mogObject != null){
				var String tObjName = null;
				var String mObjName = null;
				var String dObjName = null;
				var String pObjName = null;
				for (oo: o.mogObject.objects){
					if (objects.containsKey(oo.name)){
						if (objects.get(oo.name).dataObject != null) dObjName = oo.name;
						if (objects.get(oo.name).modelObject != null) mObjName = oo.name;
						if (objects.get(oo.name).parameterObject != null) pObjName = oo.name;
						if (objects.get(oo.name).taskObject != null) tObjName = oo.name;
					}
				}
				for (b: objects.get(tObjName).taskObject.blocks){
					if ((b.estimateBlock != null) || (b.simulateBlock != null)){
						var stepType = BLK_ESTIM_STEP;
						val key = mObjName + "-" + dObjName + "-" + pObjName;	
						val mog = new ModellingObjectGroup(mObjName, pObjName, dObjName, tObjName);
						if (!MOGs.containsKey(key)) MOGs.put(key, mog);	
						if (b.simulateBlock != null) stepType = BLK_SIMUL_STEP;
						operations.add(new Operation(tObjName, stepType, mog));
					}
				}
			}
		}
		'''
			<?xml version="1.0" encoding="UTF-8"?>
			<PharmML 
				«print_PharmML_NameSpaces»
				writtenVersion="«writtenVersion»">
				<ct:Name>"«mathPrinter.fileName(m)» - generated by MDL2PharmML v.«mathPrinter.mdlVersion»"</ct:Name>
				«FOR s: resolver.ind_vars»
					<IndependentVariable symbId="«s»"/>
				«ENDFOR»
				«FOR mog: MOGs.entrySet»
					«mdPrinter.print_mdef_ModelDefinition(mog.value.getModelObjName(), mog.value.getParamObjName())»
				«ENDFOR»
				«FOR op: operations»
					«msPrinter.print_msteps_ModellingSteps(op)»
				«ENDFOR»
				«FOR mog: MOGs.entrySet»
					«tdPrinter.print_design_TrialDesign(mog.value.getModelObjName(), mog.value.getParamObjName())»
				«ENDFOR»
			</PharmML>
		'''			
	}
	
	def extractTargetCode(Mcl mcl){
		var tcbIterator = mcl.eAllContents;
		var res = "";
	   	while (tcbIterator.hasNext) {
			var container = tcbIterator.next;
			if (container instanceof TargetBlock) {
				var s = container as TargetBlock;
				res  = res + s.extractExternalCode;
			}
		}
		return res;
	}
	
	def extractTargetCode(MclObject obj){
		var tcbIterator = obj.eAllContents;
		var res = "";
	   	while (tcbIterator.hasNext) {
			var container = tcbIterator.next;
			if (container instanceof TargetBlock) {
				var s = container as TargetBlock;
				res  = res + s.extractExternalCode;
			}
		}
		return res;
	}
	
	protected def extractExternalCode(TargetBlock s){
		val mdlPrinter = MdlPrinter::getInstance();
    	'''
			<targetBlock>
			«IF s.arguments != null»
				«FOR a: s.arguments.arguments»
					«IF a.argumentName != null»
						<«a.argumentName.name»>
							«mdlPrinter.toStr(a.expression)»
						</«a.argumentName.name»>
					«ENDIF»
			   	«ENDFOR»
		    «ENDIF»
				<code>
					«mdlPrinter.toStr(s)»
				</code>
			</targetBlock>	
    	'''
	}
	
	//+ Print PharmML namespaces
	protected def print_PharmML_NameSpaces()
		'''
		xmlns:xsi="«xsi»" 
		xmlns="«xmlns_pharmML»"
		xsi:schemaLocation="«xsi_schemaLocation»"
		xmlns:math="«xmlns_math»"
		xmlns:ct="«xmlns_ct»"
		xmlns:ds="«xmlns_ds»"
		xmlns:mdef="«xmlns_mdef»"
		xmlns:mstep="«xmlns_mstep»"
		xmlns:design="«xmlns_design»"
		'''
}