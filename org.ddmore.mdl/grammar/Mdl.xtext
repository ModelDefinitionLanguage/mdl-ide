grammar org.ddmore.mdl.Mdl with org.eclipse.xtext.common.Terminals
generate mdl "http://www.ddmore.org/mdl/Mdl"

Mcl hidden(WS, ML_COMMENT, SL_COMMENT):
	objects+=MclObject*;

MclObject:
	objectName=ObjectName '=' 
	(modelObject=ModelObject | 
	parameterObject=ParameterObject | 
	dataObject=DataObject | 
	taskObject=TaskObject |
	telObject=TELObject);
	
ModelObject: 
	identifier = 'mdlobj' BEGIN blocks += ModelObjectBlock* END;

ParameterObject:
	identifier = 'parobj' BEGIN blocks += ParameterObjectBlock* END;
	
DataObject:
	identifier = 'dataobj' BEGIN blocks += DataObjectBlock* END;

TaskObject:
	identifier = 'taskobj' BEGIN blocks += TaskObjectBlock* END;
	
TELObject:
	identifier = 'telobj' BEGIN statements += FunctionCallStatement* END;
	
//////////////////////////////////////////////////////////
//Model Object
//////////////////////////////////////////////////////////

ModelObjectBlock: 
	individualVariablesBlock = IndividualVariablesBlock | 
	modelPredictionBlock = ModelPredictionBlock |
	randomVariableDefinitionBlock = RandomVariableDefinitionBlock |
	inputVariablesBlock = InputVariablesBlock |
	structuralParametersBlock = StructuralParametersBlock |
	variabilityParametersBlock = VariabilityParametersBlock |
	outputVariablesBlock = OutputVariablesBlock |
	groupVariablesBlock = GroupVariablesBlock | 
	observationBlock = ObservationBlock |
	estimationBlock = EstimationBlock |
	simulationBlock = SimulationBlock |
	targetBlock = TargetBlock 
;

IndividualVariablesBlock:
	identifier = 'INDIVIDUAL_VARIABLES' 
	BEGIN statements += BlockStatement* END  
;

ModelPredictionBlock:
	identifier = 'MODEL_PREDICTION' 
	BEGIN statements += ModelPredictionBlockStatement* END
;

RandomVariableDefinitionBlock:
	identifier = 'RANDOM_VARIABLE_DEFINITION' 
	BEGIN variables += SymbolDeclaration* END 
;

InputVariablesBlock:
  	identifier = 'MODEL_INPUT_VARIABLES' 
  	BEGIN variables += SymbolDeclaration* END 
;

StructuralParametersBlock:
  identifier = 'STRUCTURAL_PARAMETERS' 
  BEGIN parameters += SymbolDeclaration* END 
; 

VariabilityParametersBlock:
  identifier = 'VARIABILITY_PARAMETERS' 
  BEGIN parameters += SymbolDeclaration* END 
;

OutputVariablesBlock:
	identifier = 'MODEL_OUTPUT_VARIABLES' 
	BEGIN variables += SymbolName* END 
; 

GroupVariablesBlock:
	identifier = 'GROUP_VARIABLES' 
	BEGIN statements += GroupVariablesBlockStatement* END
;

ObservationBlock:
	identifier = 'OBSERVATION'
	BEGIN statements += BlockStatement* END  
;

EstimationBlock:
	identifier = 'ESTIMATION' 
	BEGIN statements += BlockStatement* END 
;

SimulationBlock:
	identifier = 'SIMULATION' 
	BEGIN statements += BlockStatement* END  
;

//////////////////////////////////////////////////////////
//Parameter Object
//////////////////////////////////////////////////////////

ParameterObjectBlock:
	structuralBlock = StructuralBlock |
	variabilityBlock = VariabilityBlock |
	priorBlock = PriorParametersBlock |
	targetBlock = TargetBlock 
;

StructuralBlock:
	identifier='STRUCTURAL'   
	BEGIN parameters += SymbolDeclaration* END 
;

VariabilityBlock:
	identifier='VARIABILITY' 
	BEGIN statements += VariabilityBlockStatement* END
;

PriorParametersBlock:
	identifier='PRIOR_PARAMETERS' 
	BEGIN statements += BlockStatement* END  
;

//////////////////////////////////////////////////////////
//Data Object
//////////////////////////////////////////////////////////

DataObjectBlock:
	dataInputBlock = DataInputBlock |
	dataDerivedBlock = DataDerivedBlock |
	sourceBlock = SourceBlock |
	targetBlock = TargetBlock 
;
 
DataInputBlock:
 	identifier='DATA_INPUT_VARIABLES' 
 	BEGIN variables += SymbolDeclaration* END  
;
 
DataDerivedBlock:
 	identifier='DATA_DERIVED_VARIABLES' 
 	BEGIN statements += BlockStatement* END  
; 
 
SourceBlock:
	identifier='SOURCE' 	
	BEGIN 
		symbolName = SymbolName "=" list = List
		(inlineBlock = InlineBlock)? 
	END
;
 
//////////////////////////////////////////////////////////
//Task Object
//////////////////////////////////////////////////////////
 
TaskObjectBlock: 
	functionDeclaration = TaskFunctionDeclaration | 
	parameterBlock = ParameterBlock |
	dataBlock = DataBlock |
	modelBlock = ModelBlock | 
	targetBlock = TargetBlock 	
;

ParameterBlock:
	identifier = 'PARAMETER' 
	BEGIN parameters += SymbolDeclaration* END  
;

DataBlock:
	identifier = 'DATA' 
	BEGIN statements += DataBlockStatement* END
;

DataBlockStatement:
	ignoreList = IgnoreList | acceptList = AcceptList | dropList = DropList
;

IgnoreList:
	identifier = 'IGNORE' "=" 'if' '(' expression = OrExpression ')'
;

AcceptList:
	identifier = 'ACCEPT' "=" 'if' '(' expression = AndExpression ')'
; 

DropList:
	identifier = 'DROP' "=" list = SymbolList
;

AddList:
	identifier = 'ADD' '=' list = SymbolList
;

RemoveList:
	identifier = 'REMOVE' '=' list = SymbolList
;

ModelBlock:
	identifier = 'MODEL' 
	BEGIN statements += ModelBlockStatement* END
;

ModelBlockStatement:
	statement = BlockStatement |
	addList = AddList |
	removeList = RemoveList
;

SymbolList: 
	identifier = 'list' '(' symbols += SymbolName (=> ',' symbols += SymbolName)* ')'
;

ModelPredictionBlockStatement: 
	statement = BlockStatement | 
	odeBlock = OdeBlock | 
	libraryBlock = LibraryBlock |
	compartmentBlock = CompartmentBlock |
	degBlock = DeqBlock
;

LibraryBlock: 
	identifier = 'LIBRARY' 
	BEGIN statements += FunctionCallStatement* END 
;

CompartmentBlock:
	identifier = 'COMPARTMENT'
	BEGIN variables += SymbolDeclaration* END 
;

DeqBlock:
	identifier = 'DEQ'
	BEGIN variables += SymbolDeclaration* END 
;

FunctionCallStatement:
	symbolName = SymbolName "=" expression = FunctionCall
;

OdeBlock:
	identifier = 'ODE' 
	BEGIN statements += BlockStatement* END 
;

GroupVariablesBlockStatement:
	statement = BlockStatement |  
	mixtureBlock = MixtureBlock 
;

MixtureBlock:
	identifier = 'MIXTURE' 
	BEGIN statements += BlockStatement* END 
;

VariabilityBlockStatement:
	parameter = SymbolDeclaration | 
	matrixBlock = MatrixBlock | 
	diagBlock = DiagBlock	|
	sameBlock = SameBlock
;

MatrixBlock:
	 identifier = 'matrix' '(' arguments = Arguments ')'
	 (BEGIN parameters = Symbols END)?  
;

DiagBlock:	  
	 identifier = 'diag' '(' arguments = Arguments ')'
	 (BEGIN parameters = Symbols END)?  
;

SameBlock:	  
	 identifier = 'same' '(' arguments = Arguments ')'
	 (BEGIN parameters = SymbolNames END)?  
;

Symbols:
	symbols += Symbol (=> ',' symbols += Symbol)*
;

Symbol:
	symbolName = SymbolName "=" expression = AnyExpression |
	expression = AnyExpression
;

SymbolNames:
	symbolNames += SymbolName (=> ',' symbolNames += SymbolName)*
;

//////////////////////////////////////////////////////////
//Data Object
//////////////////////////////////////////////////////////

InlineBlock:
	identifier = 'INLINE' 
	BEGIN (variables = VariableList)? (values = NumericList)? END 
;

NumericList:
	values += NumericValue (=> (',' | ';')? values += (NumericValue | '.'))* 
;

VariableList:
	identifiers += SymbolName (=> (',' | ';')? identifiers += SymbolName)* //Ref to VaraibleName +
;
	
TaskFunctionDeclaration:
	functionName = FunctionName "=" 'function'   
	'(' formalArguments = FormalArguments ')'
	functionBody = TaskFunctionBody
;

TaskFunctionBody: {TaskFunctionBody}	
	BEGIN (blocks += TaskFunctionBlock)* END
;

TaskFunctionBlock:
	estimateBlock = EstimateTask |
	simulateBlock = SimulateTask |
	executeBlock = ExecuteTask
;

EstimateTask: 
	identifier = 'ESTIMATE' 
	BEGIN statements += BlockStatement* END 
;

SimulateTask:
	identifier = 'SIMULATE' 
	BEGIN statements += BlockStatement* END  
;

ExecuteTask:
	identifier = "EXECUTE"
	BEGIN statements += BlockStatement* END  
;

//////////////////////////////////////////////////////////
//Common
//////////////////////////////////////////////////////////

FormalArguments:
	arguments += ArgumentName (=> ',' arguments += ArgumentName)*
;

ArgumentName:
	name=ID
;

FunctionName:
	name=ID
;

FunctionCall:
	identifier = FullyQualifiedFunctionName '(' arguments = Arguments? ')' 
;

BlockStatement:
	symbol = SymbolDeclaration |
	functionCall = FunctionCall |
	statement = ConditionalStatement |
	targetBlock = TargetBlock
;

TargetBlock: 
	identifier = 'TARGET_CODE' ('(' arguments = Arguments ')' )? 
	BEGIN  externalCode = EXTERNAL_CODE END
;

TargetLanguage:
	identifier = ('NMTRAN_CODE' | 
	'MLXTRAN_CODE' | 
	'PML_CODE' | 
	'BUGS_CODE' | 
	'R_CODE' | 
	'MATLAB_CODE') 	
;

terminal EXTERNAL_CODE:
	'***' -> '***'
; 

SymbolName:
	name = ID
;

SymbolDeclaration:
	(symbolName = SymbolName | argumentName = FullyQualifiedArgumentName)
		("=" expression = AnyExpression | randomList = RandomList)? 
	| (functionName = FunctionName '(' (symbolName = SymbolName | argumentName = FullyQualifiedArgumentName) ')') 
		("=" expression = AnyExpression | randomList = RandomList)		
;

EnumType:
	type = VarType |
	use = UseType |       
	target = TargetLanguage |
	variability = VariabilityType |
	interpolation = InterpolationType |
	input = InputType 
;

Constant:
	identifier = ('INF' | 'T' | 'NEWIND' | 'IREP' | 'ICALL' | 'MIXEST' | 'MIXNUM')
;

VarType:
	categorical = 'categorical' ('(' arguments = FormalArguments ')')? | 
	continuous = 'continuous' | 
	likelihood = 'likelihood' |
	M2LL = 'M2LL' 	
;

InputType:
	identifier = ('nonmemFormat' | 'eventFormat')
;

InterpolationType:
	identifier = (
		'constant' | 'linear' | 'nearest' | 'spline' | 'pchip' | 'cubic'
	)
;

UseType:
	identifier = ('id'| 
	'idv' |
	'amt' | 
	'dv' | 
	'dvid' | 
	'ytype' | 
	'itype' |
	'covariate' |
	'reg' | 
	'time' | 
	'dose'| 
	'cat' | 
	'occ' | 
	'occasion' | 
	'adm' | 
	'cens' | 
	'limit' | 
	'rate' | 
	'tinf' | 
	'ss' | 
	'addl' | 
	'ii' | 
	'tau' | 
	'mdv' | 
	'evid' | 
	'cmt')
;

VariabilityType:
	identifier = ('SD' | 'VAR')
;

Distribution: 
	identifier = ('bernoulli' |
	'betaDistribution' |
	'binomial' |
	'categorical' | 
	'cauchy' | 	
	'chiSquare' |
	'dirichlet' | 	
	'exponential' | 	
	'fDistribution' |
	'gamma' | 
	'geometric' | 
	'hypergeometric' |
	'inverseGamma' |	
	'laplace' |	
	'logistic' |
	'logNormal'	|
	'multinomial' |
	'multivariateNormal' | 	
	'multivariateStudentT' | 	
	'negativeBinomial' |
	'normal' |
	'normalInverseGamma' |
	'pareto' |
	'poisson' |
	'unif' |
	'studentT' |
	'uniform' |
	'weibull' |
	'wishart' |
	//mixtute models: mixtureModel left for compatibility
	'mixtureModel' |  	
	'discreteUnivariateMixtureModel' |
    'discreteMultivariateMixtureModel' |
    'categoricalUnivariateMixtureModel' |
	'categoricalMultivariateMixtureModel' |
	'continuousMultivariateMixtureModel' |
	'continuousUnivariateMixtureModel'
	)
;

AnyExpression:
	expression = Expression |
	list = List | 
	odeList = OdeList |
	vector = Vector |
	type = EnumType 
;

List:
	identifier = 'list' '(' arguments = Arguments ')'
;

OdeList:
	 identifier = 'ode' '(' arguments = Arguments ')' 
;

RandomList:
	identifier = '~' '(' arguments = DistributionArguments ')'
;

DistributionArguments:
	arguments += DistributionArgument (=> ',' arguments += DistributionArgument)*
;

DistributionArgument: 
	(argumentName = ArgumentName "=")? (distribution = Distribution | value = Primary | component = RandomList)
; 

Arguments: 
	arguments += Argument (=> ',' arguments += Argument)*
;

Argument:
	argumentName = ArgumentName "=" expression = AnyExpression |
	expression = AnyExpression
;

ConditionalStatement:
	'if' '('expression=OrExpression')' 
		(ifStatement = BlockStatement | ifBlock = Block)
	(=> 'else' 
		(elseStatement = BlockStatement | elseBlock = Block)
	)? 
;

Block: {Block}
	BEGIN statements += BlockStatement* END
;

ParExpression:
	'(' expression = Expression')';
	
Expression:
	conditionalExpression = ConditionalExpression 
;	
	
ConditionalExpression:
	expression = OrExpression ('?' expression1 = Expression ':' expression2 = Expression)?;

OrExpression:
	expression += AndExpression (operator += LogicalOrOperator expression += AndExpression)*;

AndExpression:
	expression += LogicalExpression (operator += LogicalAndOperator expression += LogicalExpression)*;	

LogicalExpression:
	(negation = "!")? (
		(boolean = BOOLEAN) | 
		(expression1 = AdditiveExpression (operator = LogicalOperator expression2 = AdditiveExpression)?)
	)
;

AdditiveExpression:
	expression += MultiplicativeExpression (operator += AdditiveOperator expression+=MultiplicativeExpression)* |
	string = STRING	 
;

MultiplicativeExpression:
	expression += PowerExpression (operator += MultiplicativeOperator expression += PowerExpression)*;

PowerExpression:
	expression += UnaryExpression (operator += PowerOperator expression += UnaryExpression)*;

UnaryExpression:
	operator = UnaryOperator expression = UnaryExpression |  
	parExpression = ParExpression |
	number = NumericValue |
	symbol = SymbolName |
	constant = Constant |
	attribute = FullyQualifiedArgumentName | 
	functionCall = FunctionCall 
;


Primary:
	number = NumericValue |
	symbol = SymbolName | 
	vector = Vector 
;

Vector:
	identifier = 'c' '(' values += Primary (=> ',' values += Primary)* ')'
;	

FullyQualifiedFunctionName: 
	(object = [ObjectName] '$')? function = FunctionName
;

FullyQualifiedArgumentName:
	parent = SymbolName selectors += Selector+  
;

Selector:
	('.' argumentName = ArgumentName ) | ('[' selector = INTEGER ']')
;

ObjectName:
	name = ID
;

LogicalAndOperator: '&&'
;		

LogicalOrOperator: '||'
;

LogicalOperator:
	'<' | 
	'>' | 
	"<=" | 
	">=" | 
	'==' | 
	'!=';

PowerOperator:
	'^'
;

MultiplicativeOperator:
	'*' | '/' | '%'  
;	

AdditiveOperator:
	'+' | '-'
;

UnaryOperator:
	'+' | '-' 
;

NumericValue:	
	INTEGER | FLOAT
; 
	
terminal STRING:
	'"' (ESCAPE_SEQUENCE | !('\\' | '"'))* '"';

terminal fragment ESCAPE_SEQUENCE:
	'\\' ('b' | 't' | 'n' | 'f' | 'r' | '\"' | '\'' | '\\')
	| UNICODE_ESCAPE
	| OCTAL_ESCAPE;

terminal fragment OCTAL_ESCAPE:
	  '\\' ('0'..'3') ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7');

terminal fragment UNICODE_ESCAPE:
	'\\' 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT;

terminal fragment HEXDIGIT:
	('0'..'9' | 'a'..'f' | 'A'..'F');
	
terminal BOOLEAN:
    'true' | 'false';		
	
terminal INTEGER:
	('0' | '1'..'9' '0'..'9'*);
	
terminal FLOAT
    : '0'..'9' + '.' '0'..'9'* EXPONENT?
    | '.' '0'..'9'+ EXPONENT?
    | '0'..'9'+ EXPONENT
    | ('0'..'9')
    ;

terminal fragment EXPONENT
	: ('e'|'E'|'d'|'D') ('+'|'-')?('0'..'9')+;

terminal SL_COMMENT : ('#') !('\n'|'\r')* ('\r'? '\n')? ;

terminal ML_COMMENT : '/#' -> '#/';

terminal BEGIN: '{';

terminal END: '}' ;

terminal ID: ('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'| '0'..'9')*;



