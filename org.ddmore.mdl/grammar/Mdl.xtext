grammar org.ddmore.mdl.Mdl with org.eclipse.xtext.common.Terminals
generate mdl "http://www.ddmore.org/mdl/Mdl"

Mcl hidden(WS, ML_COMMENT, SL_COMMENT):
	objects+=MclObject*;

MclObject:
	objectName=ObjectName '=' 
	(modelObject=ModelObject | 
	parameterObject=ParameterObject | 
	dataObject=DataObject | 
	taskObject=TaskObject |
	designObject=DesignObject |
	mogObject=MOGObject);
	
ModelObject: 
	identifier = 'mdlobj' BEGIN blocks += ModelObjectBlock* END;

ParameterObject:
	identifier = 'parobj' BEGIN blocks += ParameterObjectBlock* END;
	
DataObject:
	identifier = 'dataobj' BEGIN blocks += DataObjectBlock* END;

TaskObject:
	identifier = 'taskobj' BEGIN blocks += TaskObjectBlock* END;
	
DesignObject:
	identifier = 'designobj' BEGIN blocks += DesignObjectBlock* END;
	
MOGObject:
	identifier = 'mogobj' BEGIN blocks += MOGObjectBlock* END;
	
//////////////////////////////////////////////////////////
//Model Object
//////////////////////////////////////////////////////////

ModelObjectBlock: 
	individualVariablesBlock = IndividualVariablesBlock | 
	modelPredictionBlock = ModelPredictionBlock | 
	randomVariableDefinitionBlock = RandomVariableDefinitionBlock |
	variabilityBlock = VariabilityDefinitionBlock |
	covariateBlock = CovariateDefinitionBlock |
	structuralParametersBlock = StructuralParametersBlock |
	variabilityParametersBlock = VariabilityParametersBlock |
	outputVariablesBlock = OutputVariablesBlock | 
	groupVariablesBlock = GroupVariablesBlock | 
	observationBlock = ObservationBlock |
	estimationBlock = EstimationBlock |
	simulationBlock = SimulationBlock |
	targetBlock = TargetBlock 
;

IndividualVariablesBlock:
	identifier = 'INDIVIDUAL_VARIABLES'
	BEGIN variables += SymbolDeclaration* END  
;

ModelPredictionBlock:
	identifier = 'MODEL_PREDICTION' 
	BEGIN statements += ModelPredictionBlockStatement* END
;

RandomVariableDefinitionBlock:
	identifier = 'RANDOM_VARIABLE_DEFINITION' '(' arguments = Arguments? ')'
	BEGIN variables += SymbolDeclaration* END 
;

VariabilityDefinitionBlock:
  	identifier = 'VARIABILITY' 
  	BEGIN variables += SymbolDeclaration* END 
;

CovariateDefinitionBlock:
  	identifier = 'COVARIATE' 
  	BEGIN variables += SymbolDeclaration* END 
;

StructuralParametersBlock:
  identifier = 'STRUCTURAL_PARAMETERS' 
  BEGIN parameters += SymbolDeclaration* END 
; 

VariabilityParametersBlock:
  identifier = 'VARIABILITY_PARAMETERS' 
  BEGIN parameters += SymbolDeclaration* END 
;

OutputVariablesBlock:
	identifier = 'MODEL_OUTPUT_VARIABLES' 
	BEGIN variables += SymbolName* END 
; 

GroupVariablesBlock:
	identifier = 'GROUP_VARIABLES' 
	BEGIN statements += GroupVariablesBlockStatement* END
;

ObservationBlock:
	identifier = 'OBSERVATION'
	BEGIN variables += SymbolDeclaration* END  
;

EstimationBlock:
	identifier = 'ESTIMATION' 
	BEGIN variables += SymbolDeclaration* END 
;

SimulationBlock:
	identifier = 'SIMULATION' 
	BEGIN variables += SymbolDeclaration* END  
;

//////////////////////////////////////////////////////////
//Parameter Object
//////////////////////////////////////////////////////////

ParameterObjectBlock:
	structuralBlock = StructuralBlock |
	variabilityBlock = VariabilityBlock |
	priorBlock = PriorParametersBlock |
	targetBlock = TargetBlock 
;

StructuralBlock:
	identifier='STRUCTURAL'   
	BEGIN parameters += SymbolDeclaration* END 
;

VariabilityBlock:
	identifier='VARIABILITY' 
	BEGIN parameters += SymbolDeclaration* END
;

PriorParametersBlock:
	identifier='PRIOR_PARAMETERS' 
	BEGIN parameters += SymbolDeclaration* END  
;

//////////////////////////////////////////////////////////
//Data Object
//////////////////////////////////////////////////////////

DataObjectBlock:
	dataInputBlock = DataInputBlock |
	sourceBlock = SourceBlock |
	targetBlock = TargetBlock |
	observationBlock = ObservationBlock |
	dosingVariables = DosingVariablesBlock
;

DosingVariablesBlock:
 	identifier='DOSING_VARIABLES' 
 	BEGIN variables += SymbolDeclaration* END  	
;
 
DataInputBlock:
 	identifier='DATA_INPUT_VARIABLES' 
 	BEGIN variables += SymbolDeclaration* END  
;
 
SourceBlock:
	identifier='SOURCE' 	
	BEGIN 
		statements += PropertyDeclaration* 
		(inlineBlock = InlineBlock)?
	END
;

//////////////////////////////////////////////////////////
//Task Object
//////////////////////////////////////////////////////////
 
TaskObjectBlock: 
	estimateBlock = EstimateTask |
	simulateBlock = SimulateTask |
	evaluateBlock = EvaluateTask |
	optimiseBlock = OptimiseTask |
	dataBlock = DataBlock |
	modelBlock = ModelBlock | 
	targetBlock = TargetBlock 	
;

DataBlock:
	identifier = 'DATA' 
	BEGIN statements += PropertyDeclaration* END
;

ModelBlock:
	identifier = 'MODEL' 
	BEGIN statements += PropertyDeclaration* END
;

EstimateTask: 
	identifier = 'ESTIMATE' 
	BEGIN statements += PropertyDeclaration* END 
;

SimulateTask:
	identifier = 'SIMULATE' 
	BEGIN statements += PropertyDeclaration* END  
;

EvaluateTask:
	identifier = 'EVALUATE'
	BEGIN statements += PropertyDeclaration* END  
;

OptimiseTask:
	identifier = 'OPTIMISE'
	BEGIN statements += PropertyDeclaration* END  
;

ModelPredictionBlockStatement: 
	variable = SymbolDeclaration | 
	odeBlock = OdeBlock | 
	libraryBlock = LibraryBlock |
	pkMacroBlock = PkMacroBlock 
;

LibraryBlock: 
	identifier = 'LIBRARY' 
	BEGIN statements += FunctionCallStatement* END 
;

PkMacroBlock:
	identifier = 'PKMACRO'
	BEGIN statements += PkMacroStatement* END 
;

PkMacroStatement:
	variable = SymbolDeclaration |
	list = List
;

FunctionCallStatement:
	symbolName = SymbolName "=" expression = FunctionCall
;

OdeBlock:
	identifier = ('ODE' | 'DEQ')
	BEGIN variables += SymbolDeclaration* END 
;

GroupVariablesBlockStatement:
	variable = SymbolDeclaration |  
	mixtureBlock = MixtureBlock 
;

MixtureBlock:
	identifier = 'MIXTURE' 
	BEGIN variables += SymbolDeclaration* END 
;

//////////////////////////////////////////////////////////
//Data Object
//////////////////////////////////////////////////////////

InlineBlock:
	identifier = 'INLINE' 
	BEGIN (variables = VariableList)? (values = NumericList)? END 
;

NumericList:
	values += SignedNumericValue (=> (',' | ';')? values += SignedNumericValue)* 
;

SignedNumericValue:
	(operator = UnaryOperator)? value = NumericValue | skip = '.'
;

VariableList:
	identifiers += SymbolName (=> (',' | ';')? identifiers += SymbolName)* 
;

//////////////////////////////////////////////////////////
//Design Object
//////////////////////////////////////////////////////////

DesignObjectBlock:
	covariatesBlock = CovariatesBlock |
	studyDesignBlock = StudyDesignBlock |
	adminBlock = AdministrationBlock |
	actionBlock = ActionBlock |
	samplingBlock = SamplingBlock |
	designSpaceBlock = DesignSpaceBlock |
	hyperSpaceBlock = HyperSpaceBlock |
	populationFeaturesBlock = PopulationFeaturesBlock |
	targetBlock = TargetBlock
;

DesignSpaceBlock:
	identifier = 'DESIGN_SPACE'
	BEGIN variables += SymbolDeclaration* END 
;

HyperSpaceBlock:
	identifier = 'HYPER_SPACE'
	BEGIN variables += SymbolDeclaration* END 
;

CovariatesBlock:
	identifier = 'COVARIATES'
	BEGIN variables += SymbolDeclaration* END 
;

StudyDesignBlock:
	identifier = 'STUDY_DESIGN'
	BEGIN variables += SymbolDeclaration* END 
;

PopulationFeaturesBlock:
	identifier = 'POPULATION_FEATURES'
	BEGIN variables += PropertyDeclaration* END
;

AdministrationBlock:
	identifier = 'ADMINISTRATION'
	BEGIN variables += SymbolDeclaration* END
;

ActionBlock:
	identifier = 'ACTION'
	BEGIN variables += SymbolDeclaration* END
;

SamplingBlock:
	identifier = 'SAMPLING'
	BEGIN variables += SymbolDeclaration* END
;

//////////////////////////////////////////////////////////
//MOG
//////////////////////////////////////////////////////////
MOGObjectBlock:
	objectBlock = ImportObjectBlock |
	mappingBlock = MappingBlock	
;

 ImportObjectBlock:
 	identifier = 'OBJECTS'
 	BEGIN objects += ImportObjectStatement* END
 ;
 
 ImportObjectStatement:
 	symbolName = SymbolName "=" objectName = [ObjectName] ('from' importURI = STRING)?
 ;
 
 MappingBlock:
 	identifier = 'MAPPING'
 	BEGIN mappings += MappingBlockStatement* END
 ;
 
 MappingBlockStatement:
 	obj1 = SymbolName '.' var1 = SymbolName '=' obj2 = SymbolName '.' var2 = SymbolName
 ;

//////////////////////////////////////////////////////////
//Common
//////////////////////////////////////////////////////////

FormalArguments:
	arguments += ArgumentName (=> ',' arguments += ArgumentName)*
;

ArgumentName:
	name=ID
;

FunctionName:
	name=ID
;

FunctionCall:
	identifier = FunctionName '(' arguments = Arguments? ')' 
;

TargetBlock: 
	identifier = 'TARGET_CODE' 
	BEGIN
		statements += PropertyDeclaration*  
		externalCode = EXTERNAL_CODE 
	END
;

terminal EXTERNAL_CODE:
	'<<' -> '>>'
; 

SymbolName:
	name = ID
;

SymbolDeclaration:
	(symbolName = SymbolName | 
		argumentName = FullyQualifiedArgumentName
	)
		("=" (expression = Expression) | 
		":" list = List | 
		randomList = RandomList)? 
	| (functionName = FunctionName '(' (symbolName = SymbolName 
		| argumentName = FullyQualifiedArgumentName
	) ')' 
		("=" (expression = Expression)| 
		":" list = List | 
		randomList = RandomList))		
;

PropertyDeclaration:
	propertyName = ArgumentName "=" expression = AnyExpression
;

EnumType:
	type = VarType |
	use = UseType |       
	target = TargetType|
	variability = VariabilityType |
	input = InputFormatType |
	trial = TrialType |
	individualVar = IndividualVarType |
	pkParameter = PkParameterType |
	pkMacro = PkMacroType
;

enum PkParameterType:
	no_param | v_cl | v_k | vss_cl | abk
;

enum PkMacroType:
	no_macro | iv | elimination | oral | compartment | transfer | peripheral | absorption
;

enum UseType:
	no_use | id | idv | amt | dv | dvid | ytype | itype | covariate | reg | dose | cat | 
	occ | adm | cens | limit | rate | tinf | ss | addl | ii | tau | mdv |evid | cmt
;

enum TargetType:
	no_target | NMTRAN_CODE | MLXTRAN_CODE | PML_CODE | BUGS_CODE | R_CODE | MATLAB_CODE 	
;

enum InputFormatType:
	no_inputFormat | nonmemFormat | eventFormat 
;

enum VariabilityType:
	no_variability | SD | VAR | COV | CORR
;

enum IndividualVarType:
	no_IndividualVar | linear | general
;

enum TrialType:
	no_Trial | simple | combined | sequential 
;

terminal CONSTANT:
	'INF' | 'T' | 'NEWIND' | 'IREP' | 'ICALL' | 'MIXEST' | 'MIXNUM'
;

VarType:
	categorical = 'categorical' ('(' categories += Category (=> ',' categories += Category)* ')')? | 
	continuous = 'continuous' | 
	likelihood = 'likelihood' |
	M2LL = 'M2LL' 	
;

Category:
	categoryName = ArgumentName
;

AnyExpression:
	expression = Expression |
	list = List | 
	vector = Vector |
	//matching = Matching |
	type = EnumType 
;

Matching:
	symbolName = SymbolName '<=>' condition = OrExpression
;

List:
	BEGIN arguments = Arguments END
;

RandomList:
	'~' type = DistributionName '(' arguments = Arguments? ')'
;

DistributionName:
	name = ID
;

Arguments: 
	arguments += Argument (=> ',' arguments += Argument)*
;

Argument:
	(argumentName = ArgumentName ("=" expression = AnyExpression | randomList = RandomList)) | 
	expression = AnyExpression | randomList = RandomList
;

ParExpression:
	'(' expression = Expression')';	
	
Expression:
	expression = OrExpression ('when' condition = OrExpression 
	(=> ',' whenBranches += ExpressionBranch)*
	(';' | 'otherwise' elseExpression = OrExpression (';')?)
	)?
;

ExpressionBranch:
	expression = OrExpression 'when' condition = OrExpression
;	
	
OrExpression:
	expression += AndExpression (operator += LogicalOrOperator expression += AndExpression)*;

AndExpression:
	expression += LogicalExpression (operator += LogicalAndOperator expression += LogicalExpression)*;	

LogicalExpression:
	(negation = "!")? (
		(boolean = BOOLEAN) | 
		(expression1 = AdditiveExpression (operator = LogicalOperator expression2 = AdditiveExpression)?)
	)
;

AdditiveExpression:
	expression += MultiplicativeExpression (operator += AdditiveOperator expression+=MultiplicativeExpression)* |
	string = STRING	 
;

MultiplicativeExpression:
	expression += PowerExpression (operator += MultiplicativeOperator expression += PowerExpression)*;

PowerExpression:
	expression += UnaryExpression (operator += PowerOperator expression += UnaryExpression)*;

UnaryExpression:
	operator = UnaryOperator expression = UnaryExpression |  
	parExpression = ParExpression |
	number = NumericValue |
	symbol = SymbolName |
	constant = CONSTANT |
	attribute = FullyQualifiedArgumentName | 
	functionCall = FunctionCall 
;

Vector:
	'[' expression = VectorExpression ']'
;	

VectorExpression:
		expressions += Expression (=> ',' expressions += Expression)* |
		lists += List (=> ',' lists += List)* |
		//vectors += Vector (=> ',' vectors += Vector)* |
		matchings += Matching  (=> ',' matchings += Matching)*
;

FullyQualifiedArgumentName:
	parent = SymbolName selectors += Selector+  
;

Selector:
	('.' argumentName = ArgumentName ) | ('[' selector = INTEGER ']')
;

ObjectName:
	name = ID
;

LogicalAndOperator: '&&'
;		

LogicalOrOperator: '||'
;

LogicalOperator:
	'<' | 
	'>' | 
	"<=" | 
	">=" | 
	'==' | 
	'!=';

PowerOperator:
	'^'
;

MultiplicativeOperator:
	'*' | '/' | '%'  
;	

AdditiveOperator:
	'+' | '-'
;

UnaryOperator:
	'+' | '-' 
;

NumericValue:	
	INTEGER | FLOAT
; 
	
terminal STRING:
	'"' (ESCAPE_SEQUENCE | !('\\' | '"'))* '"';

terminal BOOLEAN:
    'true' | 'false';		
	
terminal INTEGER:
	('0' | '1'..'9' '0'..'9'*);
	
terminal FLOAT: 
	'0'..'9' + '.' '0'..'9'* EXPONENT?
    | '.' '0'..'9'+ EXPONENT?
    | '0'..'9'+ EXPONENT
    | ('0'..'9')
    ;

terminal fragment ESCAPE_SEQUENCE:
	'\\' ('b' | 't' | 'n' | 'f' | 'r' | '\"' | '\'' | '\\')
	| UNICODE_ESCAPE
	| OCTAL_ESCAPE;

terminal fragment OCTAL_ESCAPE:
	  '\\' ('0'..'3') ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7');

terminal fragment UNICODE_ESCAPE:
	'\\' 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT;

terminal fragment HEXDIGIT:
	('0'..'9' | 'a'..'f' | 'A'..'F');

terminal fragment EXPONENT
	: ('e'|'E'|'d'|'D') ('+'|'-')?('0'..'9')+;

terminal SL_COMMENT : ('#') !('\n'|'\r')* ('\r'? '\n')? ;

terminal ML_COMMENT : '/#' -> '#/';

terminal BEGIN: '{';

terminal END: '}' ;

terminal ID: ('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'| '0'..'9')*;



