grammar eu.ddmore.mdl.Mdl with org.eclipse.xtext.common.Terminals
generate mdl "http://www.ddmore.eu/mdl/Mdl"

Mcl hidden(WS, ML_COMMENT, SL_COMMENT):
	objects+=MclObject*;

MclObject returns MclObject:
	ModelObject | 
	ParameterObject | 
	DataObject | 
	TaskObject |
	MOGObject;
	
ModelObject returns MclObject: 
	{ModelObject} (name=ID '=' identifier = 'mdlobj' BEGIN blocks += ModelObjectBlock* END);

ParameterObject returns MclObject:
	{ParameterObject} (name=ID '=' identifier = 'parobj' BEGIN blocks += ParameterObjectBlock* END);
	
DataObject returns MclObject:
	{DataObject} (name=ID '=' identifier = 'dataobj' BEGIN blocks += DataObjectBlock* END);

TaskObject returns MclObject:
	{TaskObject} (name=ID '=' identifier = 'taskobj' BEGIN blocks += TaskObjectBlock* END);
	
MOGObject returns MclObject:
	{MOGObject} (name=ID '=' identifier = 'mogobj' BEGIN blocks += MOGObjectBlock* END);
	
//////////////////////////////////////////////////////////
//Model Object
//////////////////////////////////////////////////////////

ObjectBlock:
	ModelObjectBlock|
	DataObjectBlock |
	ParameterObjectBlock |
	TaskObjectBlock
;

ModelObjectBlock returns ObjectBlock: 
	IndependentVariableBlock |
	IndividualVariablesBlock | 
	ModelPredictionBlock | 
	RandomVariableDefinitionBlock |
	VariabilityDefinitionBlock |
	CovariateDefinitionBlock |
	StructuralParametersBlock |
	VariabilityParametersBlock |
	GroupVariablesBlock | 
	ObservationBlock 
;

IndependentVariableBlock:
	identifier = 'IDV'
	BEGIN variables += SymbolDeclaration* END  
;

IndividualVariablesBlock:
	identifier = 'INDIVIDUAL_VARIABLES'
	BEGIN variables += SymbolDeclaration* END  
;

ModelPredictionBlock:
	identifier = 'MODEL_PREDICTION' 
	BEGIN statements += ModelPredictionBlockStatement* END
;

RandomVariableDefinitionBlock:
	identifier = 'RANDOM_VARIABLE_DEFINITION' '(' argument = Argument ')'
	BEGIN variables += SymbolDeclaration* END 
;

VariabilityDefinitionBlock:
  	identifier = 'VARIABILITY_LEVELS' 
  	BEGIN variables += SymbolDeclaration* END 
;

CovariateDefinitionBlock:
  	identifier = 'COVARIATES' 
  	BEGIN variables += SymbolDeclaration* END 
;

StructuralParametersBlock:
  identifier = 'STRUCTURAL_PARAMETERS' 
  BEGIN parameters += SymbolDeclaration* END 
; 

VariabilityParametersBlock:
  identifier = 'VARIABILITY_PARAMETERS' 
  BEGIN parameters += SymbolDeclaration* END 
;

GroupVariablesBlock:
	identifier = 'GROUP_VARIABLES' 
	BEGIN statements += GroupVariablesBlockStatement* END
;

ObservationBlock:
	identifier = 'OBSERVATION'
	BEGIN variables += SymbolDeclaration* END  
;

//////////////////////////////////////////////////////////
//Parameter Object
//////////////////////////////////////////////////////////

ParameterObjectBlock returns ObjectBlock:
	DeclaredVariablesBlock |
	StructuralBlock |
	VariabilityBlock
;

StructuralBlock:
	identifier='STRUCTURAL'   
	BEGIN parameters += ParameterDeclaration* END 
;

ParameterDeclaration:
	name=ID '=' rhs=(EstimateRange|FixedValue)
;

EstimateRange:
	(exclusiveLow ?= '(' | '[') low=NumberLiteral? ',' initial=NumberLiteral (',' high=NumberLiteral)? (exclusiveHigh ?= ')' | ']')
;

FixedValue:
	NumberLiteral
;


VariabilityBlock:
	identifier='VARIABILITY' '(' TYPE '=' varType=(SD|VAR) ')'
	BEGIN parameters += (ParameterDeclaration|ListDeclaration)* END
;

//////////////////////////////////////////////////////////
//Data Object
//////////////////////////////////////////////////////////

DataObjectBlock returns ObjectBlock:
	DataInputBlock |
	DataDerivedBlock |
	DeclaredVariablesBlock |
	SourceBlock
;

DataInputBlock:
 	identifier='DATA_INPUT_VARIABLES' 
 	BEGIN variables += ListDeclaration* END  
;

DataDerivedBlock:
 	identifier='DATA_DERIVED_VARIABLES' 
 	BEGIN variables += ListDeclaration* END  	
;

DeclaredVariablesBlock:
 	identifier='DECLARED_VARIABLES' 
 	BEGIN variables += ReferenceDeclaration* END  	
;
 
SourceBlock:
	identifier='SOURCE' 	
	BEGIN 
		statements += PropertyDeclaration* 
//		(inlineBlock = InlineBlock)?
	END
;

//////////////////////////////////////////////////////////
//Task Object
//////////////////////////////////////////////////////////
 
TaskObjectBlock returns ObjectBlock: 
	EstimateTask |
	SimulateTask 	
;


EstimateTask: 
	identifier = 'ESTIMATE' 
	BEGIN stmt=TargetStatement? props=TargetProperties? END 
;

TargetStatement:
	TARGET '=' target=StringLiteral
;

TargetProperties:
	PROPERTIES '=' properties=StringLiteral	
;

SimulateTask:
	identifier = 'SIMULATE' 
	BEGIN statements += PropertyDeclaration* END  
;

ModelPredictionBlockStatement: 
	variable = SymbolDeclaration | 
	odeBlock = OdeBlock | 
	pkMacroBlock = PkMacroBlock 
;

PkMacroBlock:
	identifier = 'COMPARTMENT'
	BEGIN statements += PkMacroStatement* END 
;

PkMacroStatement:
	variable = SymbolDeclaration |
	list = List
;

OdeBlock:
	identifier = ('DEQ')
	BEGIN variables += SymbolDeclaration* END 
;

GroupVariablesBlockStatement:
	variable = SymbolDeclaration //|  
;


//////////////////////////////////////////////////////////
//MOG
//////////////////////////////////////////////////////////
MOGObjectBlock returns ObjectBlock:
	ImportObjectBlock
;

 ImportObjectBlock:
 	identifier = 'OBJECTS'
 	BEGIN objects += ImportObjectStatement* END
 ;
 
 ImportObjectStatement:
 	mdlObjRef = [SymbolName|ID]
 ;
 

//////////////////////////////////////////////////////////
//Common
//////////////////////////////////////////////////////////

//ArgumentName:
//	argName=ID
//;

//FunctionName:
//	funcName=(ID|TRANSFORMS)
//;
//
//FunctionCall:
//	identifier = FunctionName '(' arguments = Arguments? ')' 
//;


//terminal EXTERNAL_CODE:
//	'<<' -> '>>'
//; 

SymbolName:
	SymbolDeclaration | ListDeclaration| ReferenceDeclaration | MclObject|CategoryDefn
;

SymbolDeclaration:
	name = ID
		("=" (expression = Expression) | 
		 ":" list = List | 
		  '~' randomList = RandomList)? 
;

ListDeclaration:
	name = ID ":" list = List 
;

//ExpressionDeclaration:
//	name = ID "=" (expression = Expression) 
//;

ReferenceDeclaration:
		name = ID ';'?
;

PropertyDeclaration:
	propertyName = ID "=" expression = AnyExpression
;

EnumType:
	{EnumType}(ID_USE |
	DV |
	DVID |
	DEFINE |
	CMT |
	COVARIATE |
	AMT |
	MDV |
	RATE |
	SS |
	IDV |
	VARLEVEL |
	CONTINUOUS|
	NONMEM_FORMAT|
	PARAMETER|
	OBSERVATION|
	LINEAR|
	GENERAL|
	COMBINED_ERROR_1|
	LOG|
	LOGIT|
	PROBIT|
	IDENTITY|
	CORR|
	COV
	)
;

//New 
//enum NonContinuousType:
//	no_type | count | discrete | tte
//;
//
//enum EventType:
//	no_event | exact | intervalCensored
//;

//enum LevelType:
//	no_level | parameter | observation
//;

//enum PkParameterType:
//	no_param | v_cl | v_k | vss_cl | abk
//;

//enum PkMacroType:
//	no_macro | input | direct | effect | compartment | distribution | depot | transfer | elimination 
//;

//enum UseType:
//	no_use | id | idv | amt | dv | dvid | covariate | rate | adm | ss | mdv | cmt | varlevel
//;

//enum TargetType:
//	no_target | NMTRAN_CODE | MLXTRAN_CODE | PML_CODE | BUGS_CODE | R_CODE | MATLAB_CODE 	
//;

//enum InputFormatType:
//	no_inputFormat | nonmemFormat | eventFormat 
//;

//enum VariabilityType:
//	no_variability | SD | VAR | COV | CORR
//;

//enum IndividualVarType:
//	no_IndividualVar | linear | general
//;

//enum TrialType:
//	no_Trial | simple | combined | sequential 
//;

VarType:
	categorical = CATEGORICAL '(' categories += CategoryDefn (=> ',' categories += CategoryDefn)* ')' /* | 
	continuous  = 'continuous' | 
	likelihood  = 'likelihood' |
	M2LL = 'M2LL' |
	tte  = 'tte'	*/
;

CategoryDefn:
	name = ID
;

AnyExpression:
		Expression
	|	List
	|	Vector
	|	EnumType
	|   VarType 
;

List:
	BEGIN arguments = Arguments END
;

RandomList:
	type = DistributionName '(' arguments = Arguments? ')'
;

DistributionName:
	distName = ID
;

Arguments: 
	namedArguments = NamedArguments //| unnamedArguments = UnnamedArguments
;

NamedArguments:
	arguments += Argument (=> ',' arguments += Argument)* 
;

Argument:
	argumentName = AttributeName "=" expression = ArgumentExpression 
;

AttributeName:
	USE|DEFINE|TYPE|CATEGORY|VALUE|COLUMN|LEVEL|DERIV|INIT_TIME|INIT_VAL|TRANS|RANEFF|FIXEFF|POP|GROUP|MEAN|SD|VAR|
		ERROR|EPS|PREDICTION|COEFF|COVARIATE|ADDITIVE|PROPORTIONAL|CMT|PARAMETER|CONDITION
;

ArgumentExpression:
	expression = AnyExpression// | randomList = RandomList
;

TransformExpr:
	{TransformExpr} (LOG|LOGIT|PROBIT|IDENTITY)
;

Expression:
	OrExpression
;

OrExpression returns Expression:
	AndExpression (=>({BinaryOperation.leftOperand=current} feature=OpOr) rightOperand=AndExpression)*;

OpOr:
	'||';

AndExpression returns Expression:
	EqualityExpression (=>({BinaryOperation.leftOperand=current} feature=OpAnd) rightOperand=EqualityExpression)*;

OpAnd:
	'&&';

EqualityExpression returns Expression:
	RelationalExpression (=>({BinaryOperation.leftOperand=current} feature=OpEquality)
	rightOperand=RelationalExpression)*;

OpEquality:
	'==' | '!=' ;

RelationalExpression returns Expression:
	AdditiveExpression
	(
	 =>({BinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=AdditiveExpression)*;

OpCompare:
	'>=' | '<=' | '>' | '<' ;

AdditiveExpression returns Expression:
	MultiplicativeExpression (=>({BinaryOperation.leftOperand=current} feature=OpAdd)
	rightOperand=MultiplicativeExpression)*;

OpAdd:
	'+' | '-';

MultiplicativeExpression returns Expression:
	UnaryOperation (=>({BinaryOperation.leftOperand=current} feature=OpMulti) rightOperand=UnaryOperation)*;

OpMulti:
	'*' | '^' | '/' | '%';

UnaryOperation returns Expression:
	{XUnaryOperation} feature=OpUnary operand=UnaryOperation
	| PrimaryExpression
	;

OpUnary:
	"!" | "-" | "+";

PrimaryExpression returns Expression:
	Literal
	| SymbolReference 
	| UserFunctionCall
	| BuiltinFunction
	| WhenExpression
	| ParExpression
	;


ParExpression returns Expression:
	'(' Expression ')'
;

WhenExpression returns Expression:
	 {XIfExpression}
	 	'when' '(' if+=Expression ')' then+=Expression
	 	(=>',' 'when' '(' if+=Expression ')' then+=Expression)*
		(=>'otherwise' else=Expression)?
	;

Literal returns Expression:
	NumberLiteral |
	StringLiteral |
	BooleanLiteral
;

SymbolReference:
	{SymbolReference} ref=[SymbolName|ID]
;

UserFunctionCall:
	 ref=[SymbolName|ID] ( =>'(' (args+=Expression (=>',' args+=Expression)*)? ')')
; 

BuiltinFunction:
	{BuiltinFunction} func=BuiltinId '(' (args+=Expression (=>',' args+=Expression)*)? ')'
;

BuiltinId:
	LOG|LOGIT|PROBIT|EXP|SQRT
;

BooleanLiteral returns Expression :
	{BooleanLiteral} ('false' | isTrue?='true');

NumberLiteral returns Expression :
	{NumberLiteral} value=Number;

StringLiteral returns Expression:
	{StringLiteral} value=STRING;

Number hidden():
	(INTEGER | FLOAT) 
	;
	

Vector:
	'[' expression = VectorExpression ']'
;	

VectorExpression:
		expressions += Expression (=> ',' expressions += Expression)* |
		lists += List (=> ',' lists += List)* //|
		//vectors += Vector (=> ',' vectors += Vector)* |
		//matchings += Matching  (=> ',' matchings += Matching)*
;

terminal ID_USE: 'id';

terminal AMT : 'amt';

terminal IDV : 'idv';

terminal COVARIATE : 'covariate';

terminal DV : 'dv';

terminal DVID : 'dvid';

terminal RATE : 'rate';

terminal SS : 'ss';

terminal MDV : 'mdv';

terminal CMT : 'cmt';

terminal VARLEVEL : 'varlevel';  

terminal PARAMETER : 'parameter';

terminal OBSERVATION : 'observation';

terminal LINEAR : 'linear';

terminal GENERAL : 'general';

terminal USE: 'use';

terminal DEFINE: 'define';

terminal TYPE: 'type';

terminal CATEGORY: 'category';

terminal COLUMN: 'column';

terminal CONDITION: 'condition';

terminal CATEGORICAL: 'categorical';

terminal CONTINUOUS: 'continuous';

terminal VALUE : 'value';

terminal NONMEM_FORMAT : 'nonmemFormat';

terminal LEVEL : 'level';

terminal MEAN : 'mean';

terminal PREDICTION: 'prediction';

terminal SD : 'sd';

terminal VAR : 'var';

terminal CORR : 'corr';

terminal COV : 'cov';

terminal TRANS : 'trans';

terminal POP : 'pop';

terminal GROUP : 'group';

terminal FIXEFF : 'fixEff';

terminal COEFF : 'coeff';

terminal RANEFF : 'ranEff';

terminal ERROR : 'error';

terminal EPS : 'eps';

terminal DERIV : 'deriv';

terminal INIT_TIME : 'init';

terminal INIT_VAL : 'x0';

terminal ADDITIVE : 'additive';

terminal PROPORTIONAL : 'proportional';

terminal COMBINED_ERROR_1 : 'combinedError1';

terminal TARGET : 'target';

terminal PROPERTIES : 'properties';

terminal LOG : 'log';

terminal LOGIT : 'logit';

terminal PROBIT : 'probit';

terminal IDENTITY : 'identity';

terminal SQRT : 'sqrt';

terminal EXP : 'exp';

terminal CONSTANT:
	'INF'
;

terminal STRING:
	'"' (ESCAPE_SEQUENCE | !('\\' | '"'))* '"';

terminal INTEGER:
	('0' | '1'..'9' '0'..'9'*);
	
terminal FLOAT: 
	'0'..'9' + '.' '0'..'9'* EXPONENT?
    | '.' '0'..'9'+ EXPONENT?
    | '0'..'9'+ EXPONENT
    | ('0'..'9')
    ;

terminal fragment ESCAPE_SEQUENCE:
	'\\' ('b' | 't' | 'n' | 'f' | 'r' | '\"' | '\'' | '\\')
	| UNICODE_ESCAPE
	| OCTAL_ESCAPE;

terminal fragment OCTAL_ESCAPE:
	  '\\' ('0'..'3') ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7');

terminal fragment UNICODE_ESCAPE:
	'\\' 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT;

terminal fragment HEXDIGIT:
	('0'..'9' | 'a'..'f' | 'A'..'F');

terminal fragment EXPONENT
	: ('e'|'E'|'d'|'D') ('+'|'-')?('0'..'9')+;

terminal SL_COMMENT : ('#') !('\n'|'\r')* ('\r'? '\n')? ;

terminal ML_COMMENT : '/#' -> '#/';

terminal BEGIN: '{';

terminal END: '}' ;

terminal ID: ('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'| '0'..'9')*;


