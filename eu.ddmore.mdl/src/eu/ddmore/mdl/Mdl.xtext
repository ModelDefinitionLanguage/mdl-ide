grammar eu.ddmore.mdl.Mdl with org.eclipse.xtext.common.Terminals
generate mdl "http://www.ddmore.eu/mdl/Mdl"

Mcl hidden(WS, ML_COMMENT, SL_COMMENT):
	objects+=MclObject*;

MclObject returns MclObject:
	name=ID '=' mdlObjType=('mdlobj'|'parobj'|'dataobj'|'taskobj'|'mogobj') blkArgs=BlockArguments? BEGIN blocks += BlockStatement* END;


BlockStatement:
	identifier = ID blkArgs=BlockArguments? BEGIN
		statements+=Statement*
	END
;

BlockArguments:
	'(' args+=BlockArgument (',' args+=BlockArgument)* ')'
;

BlockArgument:
	Argument|ForwardDeclaration
;


ForwardDeclaration:
	declType=ID idv=ReferenceDeclaration
;

Statement:
	EquationDeclaration|TransformedDeclaration|ListDeclaration|
	RandomVariableDeclaration|BlockStatement|PropertyStatement
;


EstimateRange returns Expression:
	(exclusiveLow ?= '<(' | '<[') low=Number? ',' initial=Number (',' high=Number)? (exclusiveHigh ?= ')>' | ']>')
;

SymbolDeclaration:
	EquationDeclaration | ListDeclaration| ReferenceDeclaration | CategoryDefn | RandomVariableDeclaration | TransformedDeclaration
;

EquationDeclaration:
	name = ID ("=" expression = Expression)? ';'?
;

TransformedDeclaration:
	transfrom = ID '(' name=ID ')' '=' expression=Expression ';'?
;

RandomVariableDeclaration:
	name = ID "~" distn = BuiltinFunction ';'?
;

ListDeclaration:
	name = ID ":" list = List ';'?
;

ReferenceDeclaration:
		name = ID ';'?
;

PropertyStatement:
	 PropertyDefinition ';'?
;

PropertyDefinition:
	'set' Argument
;

VarType:
	categorical = CATEGORICAL '(' categories += CategoryDefn (=> ',' categories += CategoryDefn)* ')' 
;

CategoryDefn:
	name = ID
;

List:
	BEGIN arguments=Arguments END
;

Arguments:
	{Arguments} arguments += Argument (=> ',' arguments += Argument)* 
;

Argument:
	argumentName = AttributeName ("=" (expression = Expression
									|	expression=List
									|	expression=Vector
									|   expression=VarType) 
								| IS expression = EnumExpression)
;

AttributeName:
	ID
;

EnumExpression returns Expression:
	{EnumExpression}ID
;

Expression:
	OrExpression
;

OrExpression returns Expression:
	AndExpression (=>({BinaryOperation.leftOperand=current} feature=OpOr) rightOperand=AndExpression)*;

OpOr:
	'||';

AndExpression returns Expression:
	EqualityExpression (=>({BinaryOperation.leftOperand=current} feature=OpAnd) rightOperand=EqualityExpression)*;

OpAnd:
	'&&';

EqualityExpression returns Expression:
	RelationalExpression (=>({BinaryOperation.leftOperand=current} feature=OpEquality)
	rightOperand=RelationalExpression)*;

OpEquality:
	'==' | '!=' ;

RelationalExpression returns Expression:
	AdditiveExpression
	(
	 =>({BinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=AdditiveExpression)*;

OpCompare:
	'>=' | '<=' | '>' | '<' ;

AdditiveExpression returns Expression:
	MultiplicativeExpression (=>({BinaryOperation.leftOperand=current} feature=OpAdd)
	rightOperand=MultiplicativeExpression)*;

OpAdd:
	'+' | '-';

MultiplicativeExpression returns Expression:
	UnaryOperation (=>({BinaryOperation.leftOperand=current} feature=OpMulti) rightOperand=UnaryOperation)*;

OpMulti:
	'*' | '^' | '/' | '%';

UnaryOperation returns Expression:
	{XUnaryOperation} feature=OpUnary operand=UnaryOperation
	| PrimaryExpression
	;

OpUnary:
	"!" | "-" | "+";

PrimaryExpression returns Expression:
	Literal
	| SymbolReference 
	| UserFunctionCall
	| BuiltinFunction
	| WhenExpression
	| ParExpression
	| EstimateRange
	;


ParExpression returns Expression:
	'(' Expression ')'
;

WhenExpression returns Expression:
	 {XIfExpression}
	 	'when' '(' if+=Expression ')' then+=Expression
	 	(=>',' 'when' '(' if+=Expression ')' then+=Expression)*
		(=>'otherwise' else=Expression)?
	;

Literal returns Expression:
	NumberLiteral |
	StringLiteral |
	BooleanLiteral
;

SymbolReference:
	{SymbolReference} ref=[SymbolDeclaration|ID]
;


UserFunctionCall returns Expression:
	{UserFunctionCall} '&' ref=[SymbolDeclaration|ID] ( =>'(' (args+=Expression (=>',' args+=Expression)*)? ')')
; 

BuiltinFunction returns Expression:
	{BuiltinFunction} func=ID '(' funcArgs+=( UnnamedFuncArguments
							| Arguments)? ')'
;

UnnamedFuncArguments:
	args+=Expression (=>',' args+=Expression)* 
;

BooleanLiteral returns Expression :
	{BooleanLiteral} ('false' | isTrue?='true');

NumberLiteral returns Expression :
	{NumberLiteral} value=(Number|CONSTANT);

StringLiteral returns Expression:
	{StringLiteral} value=STRING;

Number hidden():
	(INTEGER | FLOAT) 
	;
	

Vector:
	'[' expression = VectorExpression ']'
;	

VectorExpression:
		expressions += Expression (=> ',' expressions += Expression)* |
		lists += List (=> ',' lists += List)*
;

terminal CATEGORICAL: 'categorical';

terminal CONSTANT:
	'INF'
;

terminal IS: 'is';


terminal STRING:
	'"' (ESCAPE_SEQUENCE | !('\\' | '"'))* '"';

terminal INTEGER:
	('0' | '1'..'9' '0'..'9'*);
	
terminal FLOAT: 
	'0'..'9' + '.' '0'..'9'* EXPONENT?
    | '.' '0'..'9'+ EXPONENT?
    | '0'..'9'+ EXPONENT
    | ('0'..'9')
    ;

terminal fragment ESCAPE_SEQUENCE:
	'\\' ('b' | 't' | 'n' | 'f' | 'r' | '\"' | '\'' | '\\')
	| UNICODE_ESCAPE
	| OCTAL_ESCAPE;

terminal fragment OCTAL_ESCAPE:
	  '\\' ('0'..'3') ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7');

terminal fragment UNICODE_ESCAPE:
	'\\' 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT;

terminal fragment HEXDIGIT:
	('0'..'9' | 'a'..'f' | 'A'..'F');

terminal fragment EXPONENT
	: ('e'|'E'|'d'|'D') ('+'|'-')?('0'..'9')+;

terminal SL_COMMENT : ('#') !('\n'|'\r')* ('\r'? '\n')? ;

terminal ML_COMMENT : '/#' -> '#/';

terminal BEGIN: '{';

terminal END: '}' ;

terminal ID: ('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'| '0'..'9')*;


