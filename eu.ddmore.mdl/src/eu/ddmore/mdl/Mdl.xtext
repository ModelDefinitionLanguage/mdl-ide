grammar eu.ddmore.mdl.Mdl with org.eclipse.xtext.common.Terminals
generate mdl "http://www.ddmore.eu/mdl/Mdl"

Mcl hidden(WS, ML_COMMENT, SL_COMMENT):
	objects+=MclObject*;

MclObject returns MclObject:
	name=ID '=' mdlObjType=('mdlobj'|'parobj'|'dataobj'|'taskobj'|'mogobj') blkArgs=BlockArguments BEGIN blocks += BlockStatement* END;


BlockStatement:
	identifier = BLOCKID blkArgs=BlockArguments BEGIN
		statements+=Statement*
	END
;

BlockArguments:
	{BlockArguments} ('(' args+=BlockArgument (',' args+=BlockArgument)* ')')?
;

BlockArgument:
	ValuePair|ForwardDeclaration
;


ForwardDeclaration:
	{ForwardDeclaration}declType=ID name=ID
;

Statement:
	EquationDefinition|TransformedDefinition|ListDefinition|
	RandomVariableDefinition|BlockStatement|PropertyStatement|
	AnonymousListStatement|EstimateDefinition
;


EstimateRange returns Expression:
	{EstimateRange}(exclusiveLow ?= '(' | '[') low=Number? ',' initial=Number (',' high=Number)? (exclusiveHigh ?= ')' | ']')
;

SymbolDefinition:
	EquationDefinition | ListDefinition| ForwardDeclaration | CategoryDefinition| RandomVariableDefinition | TransformedDefinition|
		EstimateDefinition
;

EquationDefinition:
	name = ID ("=" expression = Expression)? ';'?
;

TransformedDefinition:
	transform = ID '(' name=ID ')' '=' expression=Expression ';'?
;

RandomVariableDefinition:
	name = ID "~" distn = BuiltinFunctionCall ';'?
;

ListDefinition:
	name = ID ":" list = AttributeList ';'?
;

AnonymousListStatement:
	list = AttributeList ';'?
;


PropertyStatement:
	 SET properties+=ValuePair (',' properties+=ValuePair)* ';'?
;

EstimateDefinition:
	name = ID =>"~=" estRange=EstimateRange
;

CategoricalDefinition:
	{CategoricalDefinition} CATEGORICAL '=' '[' categories += CategoryDefinition (=> ',' categories += CategoryDefinition)* ']' 
;

CategoryDefinition:
	name = ID
;

AttributeList:
	BEGIN attributes += Attribute (=> ',' attributes += Attribute)*  END
;

Attribute:
	ValuePair|
	CategoricalDefinition
;

ValuePair:
	{ValuePair}argumentName = AttributeName ("=" expression = Expression
								| IS expression = EnumExpression
								| '=' expression = MappingExpression)
;

AttributeName:
	ID
;

EnumExpression returns Expression:
	{EnumExpression}enumValue=ID
;

MappingExpression returns Expression:
	BEGIN
		(attLists+=AttributeList (',' attLists+=AttributeList)* |
			attList+=MappingPair (',' attLists+=MappingPair)*
		)
	END
;

MappingPair:
	leftOperand=OrExpression AS rightOperand=OrExpression
;


Expression:
	OrExpression
;

OrExpression returns Expression:
	AndExpression (=>({OrExpression.leftOperand=current} feature=OpOr) rightOperand=AndExpression)*;

OpOr:
	'||';

AndExpression returns Expression:
	EqualityExpression (=>({AndExpression.leftOperand=current} feature=OpAnd) rightOperand=EqualityExpression)*;

OpAnd:
	'&&';

EqualityExpression returns Expression:
	RelationalExpression (=>({EqualityExpression.leftOperand=current} feature=OpEquality)
	rightOperand=RelationalExpression)*;

OpEquality:
	'==' | '!=' ;

RelationalExpression returns Expression:
	AdditiveExpression
	(
	 =>({RelationalExpression.leftOperand=current} feature=OpCompare) rightOperand=AdditiveExpression)*;

OpCompare:
	'>=' | '<=' | '>' | '<' ;

AdditiveExpression returns Expression:
	MultiplicativeExpression (=>({AdditiveExpression.leftOperand=current} feature=OpAdd)
	rightOperand=MultiplicativeExpression)*;

OpAdd:
	'+' | '-';

MultiplicativeExpression returns Expression:
	UnaryExpression (=>({MultiplicativeExpression.leftOperand=current} feature=OpMulti) rightOperand=UnaryExpression)*;

OpMulti:
	'*' | '^' | '/' | '%';

UnaryExpression returns Expression:
	{UnaryExpression} feature=OpUnary operand=PrimaryExpression
	| PrimaryExpression
	;

OpUnary:
	"!" | "-" | "+";

PrimaryExpression returns Expression:
	Literal
	| SymbolReference 
	| BuiltinFunctionCall
	| WhenExpression
	| ParExpression
	;


ParExpression returns Expression:
	{ParExpression} '(' expr=Expression ')'
;

WhenExpression returns Expression:
	 {WhenExpression}
	 	when+=WhenClause
	 	(=>',' when+=WhenClause)*
		(=>'otherwise' other=Expression)?
	;

WhenClause:
	'when' '(' cond=Expression ')' value=Expression
;

Literal returns Expression:
	NumberLiteral |
	StringLiteral |
	BooleanLiteral |
	VectorLiteral
;

SymbolReference:
	{SymbolReference} ref=[SymbolDefinition|ID]
;


BuiltinFunctionCall returns Expression:
	{BuiltinFunctionCall} func=ID '(' argList=(UnnamedFuncArguments	| NamedFuncArguments)? ')'
;

NamedFuncArguments returns FuncAgument:
	{NamedFuncArguments} arguments += ValuePair (=> ',' arguments += ValuePair)* 
;

UnnamedFuncArguments returns FuncAgument:
	{UnnamedFuncArguments} args+=Expression (=>',' args+=Expression)* 
;

BooleanLiteral returns Expression :
	{BooleanLiteral} ('false' | isTrue?='true');

NumberLiteral returns Expression :
	{NumberLiteral} value=(Number|CONSTANT);

StringLiteral returns Expression:
	{StringLiteral} value=STRING;

Number hidden():
	(INTEGER | FLOAT) 
	;
	

VectorLiteral returns Expression:
	{VectorLiteral} '[' expression = VectorExpression ']'
;	

VectorExpression:
		expressions += Expression (=> ',' expressions += Expression)*
;

terminal CATEGORICAL: 'categories';

terminal CONSTANT:
	'INF'
;

terminal BLOCKID:
	'MODEL_PREDICTION'|'DEQ'|'MODEL_INPUT_VARIABLES'|'RANDOM_VARIABLES'|'DECLARED_VARIABLES'|
	'INDIVIDUAL_VARIABLES'|'COVARIATES'|'ESTIMATE'|'SIMULATE'|'OPTIMISATION'|'DATA_INPUT_VARIABLES'|
	'DATA_DERIVED_VARIABLES'|'SOURCE'|'VARIABILITY'|'STRUCTURAL_PARAMETERS'|
	'VARIABILITY_LEVELS'|'VARIABILITY_PARAMETERS'|'STRUCTURAL'|'OBJECTS'|
	'GROUP_VARIABLES'|'RANDOM_VARIABLE_DEFINITION'|'COMPARTMENT'|'OBSERVATION'
;

terminal IS: 'is';

terminal AS: 'as';

terminal SET: 'set';

terminal STRING:
	'"' (ESCAPE_SEQUENCE | !('\\' | '"'))* '"';

terminal INTEGER:
	('0' | '1'..'9' '0'..'9'*);
	
terminal FLOAT: 
	'0'..'9' + '.' '0'..'9'* EXPONENT?
    | '.' '0'..'9'+ EXPONENT?
    | '0'..'9'+ EXPONENT
    | ('0'..'9')
    ;

terminal fragment ESCAPE_SEQUENCE:
	'\\' ('b' | 't' | 'n' | 'f' | 'r' | '\"' | '\'' | '\\')
	| UNICODE_ESCAPE
	| OCTAL_ESCAPE;

terminal fragment OCTAL_ESCAPE:
	  '\\' ('0'..'3') ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7');

terminal fragment UNICODE_ESCAPE:
	'\\' 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT;

terminal fragment HEXDIGIT:
	('0'..'9' | 'a'..'f' | 'A'..'F');

terminal fragment EXPONENT
	: ('e'|'E'|'d'|'D') ('+'|'-')?('0'..'9')+;

terminal SL_COMMENT : ('#') !('\n'|'\r')* ('\r'? '\n')? ;

terminal ML_COMMENT : '/#' -> '#/';

terminal BEGIN: '{';

terminal END: '}' ;

terminal ID: ('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'| '0'..'9')*;


