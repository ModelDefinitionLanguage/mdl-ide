grammar eu.ddmore.mdl.Mdl
generate mdl "http://www.ddmore.eu/mdl/Mdl"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Mcl hidden(WS, ML_COMMENT, SL_COMMENT):
	objects+=MclObject*;

MclObject returns MclObject:
	name=ID ASSIGN mdlObjType=ID blkArgs=BlockArguments BEGIN blocks += BlockStatement* END;


BlockStatement:
	identifier = ID blkArgs=BlockArguments body=(BlockStatementBody|BlockTextBody)
;

BlockStatementBody returns BlockBody:
	{BlockStatementBody}BEGIN
		statements+=Statement*
	END
;

BlockTextBody returns BlockBody:
	{BlockTextBody}text=TEXT_BLOCK
;

BlockArguments:
	{BlockArguments} ('(' args+=BlockArgument (',' args+=BlockArgument)* ')')?
;

BlockArgument:
	ValuePair
;


ForwardDeclaration:
	{ForwardDeclaration}name=ID typeSpec=TypeSpec?
;

Statement:
	EquationTypeDefinition|ListDefinition|
	RandomVariableDefinition|BlockStatement|AnonymousListStatement|
	EnumerationDefinition|PropertyStatement|//UserFunctionDefinition|
	CategoricalProbabilityAssign
;


SymbolDefinition:
	EquationDefinition | ListDefinition| ForwardDeclaration | RandomVariableDefinition | TransformedDefinition|
	  EnumerationDefinition//|UserFunctionDefinition
;


//UserFunctionDefinition:
//	{UserFunctionDefinition} name = ID typeSpec=TypeSpec '(' argument=NamedArgumentDefinitions ')'
//			(BEGIN expression = Expression END)? ';'?
//;

NamedArgumentDefinitions:
	{NamedArgumentDefinitions} arguments += ForwardDeclaration (=> ',' arguments += ForwardDeclaration)* 
;

EquationTypeDefinition:
	EquationDefinition|TransformedDefinition
;

EquationDefinition returns EquationTypeDefinition:
	{EquationDefinition} name = ID typeSpec=TypeSpec? (ASSIGN expression = Expression)? ';'?
;

TransformedDefinition returns EquationTypeDefinition:
	{TransformedDefinition} transform = ID '(' name=ID ')' ASSIGN expression=Expression ';'?
;

RandomVariableDefinition:
	(name = ID|  transform = ID '(' name=ID ')')  RANDOM_ASSIGN distn = BuiltinFunctionCall ';'?
;

TypeSpec:
	{TypeSpec} typeName=TYPE_SPEC ('[' elementType=TypeSpec ']'|'[[' cellType=TypeSpec ']]'| funcSpec=FunctionSpec)?
;


FunctionSpec:
	{FunctionSpec} '(' argument=NamedArgumentDefinitions ')'
			BEGIN expression = Expression END 
;


EnumerationDefinition:
	name = ID  catDefn=CategoricalDefinitionExpr ';'?
;

CategoricalProbabilityAssign:
	(probFunc=ProbabilityFunction ASSIGN expression=Expression  |
	transform = ID '(' probFunc=ProbabilityFunction ')' ASSIGN expression=Expression) ';'?
;

ProbabilityFunction:
	probFunc = ID '(' catRef=SymbolReference relOp=('=='|'<='|'>='|'<'|'>') catValRef=CategoryValueReference ')'
;


ListDefinition:
	name = ID LIST_ASSIGN list = AttributeList ';'?
;

AnonymousListStatement:
	ANONYMOUS_PREFIX list = AttributeList ';'?
;

PropertyStatement:
	SET properties += ValuePair (=> ',' properties += ValuePair)* ';'?
;


CategoricalDefinitionExpr returns Expression:
	{CategoricalDefinitionExpr} WITH BEGIN categories += CategoryValueDefinition (=>',' categories += CategoryValueDefinition)* END
		(ASSIGN expression = Expression)?
;

CategoryValueDefinition:
	name = ID (WHEN ordered?=ORDERED? mappedTo=Expression)?
;

AttributeList:
	BEGIN attributes += ValuePair (=> ',' attributes += ValuePair)*  END
;

ValuePair:
	(AssignPair|EnumPair)
;

AssignPair:
	argumentName = AttributeName ASSIGN expression = Expression
	
;

EnumPair:
	argumentName = AttributeName IS expression = EnumExpression
	
;

AttributeName:
	ID
;

EnumExpression returns Expression:
	{EnumExpression}enumValue=ID  (catDefn=CategoricalDefinitionExpr)?
;

MappingExpression returns Expression:
	{MappingExpression} (BEGIN
		(
			attList+=MappingPair (',' attList+=MappingPair)*
		)
	END)
;

SubListExpression returns Expression:
	{SubListExpression} BEGIN attributes += ValuePair (=> ',' attributes += ValuePair)*  END 
;

CatValRefMappingExpression returns Expression:
	{CatValRefMappingExpression}(BEGIN
		attLists+=CatValRefMapping (',' attLists+=CatValRefMapping)*
	END)
;

CatValRefMapping:
	catRef=CategoryValueReference WHEN mappedTo=Expression
;

MappingPair:
	leftOperand=OrExpression IN srcColumn=SymbolReference  AS rightOperand=OrExpression
;

//MappingList:
//	BEGIN attributes += ValuePair (=> ',' attributes += ValuePair)*  END
//;

Expression:
	OrExpression
;

OrExpression returns Expression:
	AndExpression (=>({OrExpression.leftOperand=current} feature=OpOr) rightOperand=AndExpression)*;

OpOr:
	'||';

AndExpression returns Expression:
	EqualityExpression (=>({AndExpression.leftOperand=current} feature=OpAnd) rightOperand=EqualityExpression)*;

OpAnd:
	'&&';

EqualityExpression returns Expression:
	RelationalExpression (=>({EqualityExpression.leftOperand=current} feature=OpEquality)
	rightOperand=RelationalExpression)*;

OpEquality:
	'==' | '!=' ;

RelationalExpression returns Expression:
	AdditiveExpression
	(
	 =>({RelationalExpression.leftOperand=current} feature=OpCompare) rightOperand=AdditiveExpression)*;

OpCompare:
	'>=' | '<=' | '>' | '<' ;

AdditiveExpression returns Expression:
	MultiplicativeExpression (=>({AdditiveExpression.leftOperand=current} feature=OpAdd)
	rightOperand=MultiplicativeExpression)*;

OpAdd:
	'+' | '-';

MultiplicativeExpression returns Expression:
	PowerExpression (=>({MultiplicativeExpression.leftOperand=current} feature=OpMulti) rightOperand=PowerExpression)*;

OpMulti:
	'*' | '/' | '%';

PowerExpression returns Expression:
	UnaryExpression (=>({PowerExpression.leftOperand=current} feature=OpPow) rightOperand=UnaryExpression)*;

OpPow:
	'^';

UnaryExpression returns Expression:
	{UnaryExpression} feature=OpUnary operand=PrimaryExpression
	| PrimaryExpression
	;

OpUnary:
	"!" | "-" | "+";

PrimaryExpression returns Expression:
	Literal
	| SymbolReference 
	| CategoryValueReference
	| CatValRefMappingExpression
	| MappingExpression
	| BuiltinFunctionCall
	| UserFunctionCall
	| WhenExpression
	| ParExpression
	| SubListExpression
	;


ParExpression returns Expression:
	{ParExpression} '(' expr=Expression ')'
;

WhenExpression returns Expression:
	 {WhenExpression}
	 	when+=WhenClause
	 	(=> when+=ElifClause)*
		(=>other=ElseClause)?
	;

IfExprPart:
	WhenClause | ElifClause
;

WhenClause returns IfExprPart:
	{WhenClause} IF '(' cond=Expression ')' => THEN value=Expression
;

ElifClause returns IfExprPart:
	{ElifClause} ELSEIF '(' cond=Expression ')' => THEN value=Expression
;

ElseClause:
	{ElseClause} ELSE other=Expression
;

Literal returns Expression:
	RealLiteral |
	ConstantLiteral|
	IntegerLiteral |
	StringLiteral |
	BooleanLiteral |
	VectorLiteral |
	MatrixLiteral
;

SymbolReference:
	{SymbolReference} ref=[SymbolDefinition|ID] ('[' indexExpr = IndexSpec ']')?
;

IndexSpec:
		{IndexSpec} rowIdx = IndexRange? (',' colIdx = IndexRange?)? 
			;

IndexRange:
		{IndexRange} (
			begin=Expression (LIST_ASSIGN end=Expression)?
		)
		;

CategoryValueReference:
	{CategoryValueReference} ref=[CategoryValueDefinition|QualifiedName]
;


BuiltinFunctionCall returns Expression:
	{BuiltinFunctionCall} func=ID '(' argList=(UnnamedFuncArguments	| NamedFuncArguments)? ')'
;

UserFunctionCall returns Expression:
	{UserFunctionCall} '&' ref=[SymbolDefinition|ID] '(' argList=(NamedFuncArguments)? ')'
;

NamedFuncArguments returns FuncArguments:
	{NamedFuncArguments} arguments += ValuePair (=> ',' arguments += ValuePair)* 
;

UnnamedFuncArguments returns FuncArguments:
	{UnnamedFuncArguments} args+=UnnamedArgument (=>',' args+=UnnamedArgument)* 
;

UnnamedArgument:
	{UnnamedArgument} argument=Expression
;


BooleanLiteral returns Expression :
	{BooleanLiteral} (FALSE | isTrue?=TRUE);


RealLiteral returns Expression :
	{RealLiteral} value=FLOAT;

ConstantLiteral returns Expression :
	{ConstantLiteral} value=CONSTANT;

IntegerLiteral returns Expression :
	{IntegerLiteral} value=INTEGER;

StringLiteral returns Expression:
	{StringLiteral} value=STRING;


MatrixLiteral returns Expression:
	{MatrixLiteral} '[[' (rows += MatrixRow (=> ';' rows += MatrixRow)*)? ']]'
;	

MatrixRow returns Expression:
	{MatrixRow} cells += MatrixElement (=> ',' cells += MatrixElement)*
;

MatrixElement returns Expression:
	{MatrixElement} cell=Expression
;

VectorLiteral returns Expression:
	{VectorLiteral} '[' (expressions += VectorElement (=> ',' expressions += VectorElement)*)? ']'
;	

VectorElement returns Expression:
	{VectorElement} element=Expression
;

QualifiedName:
	ID ('.' ID)
;


terminal CONSTANT:
	'inf'|'pi'|'exponentiale'
;

terminal TYPE_SPEC:
	'::' + ('A'..'Z')('a'..'z'|'A'..'Z'| '0'..'9')+
;

terminal SET: 'set';

terminal IN: 'in';

terminal IS: 'is';

terminal ASSIGN: '=';

terminal RANDOM_ASSIGN : '~';

terminal LIST_ASSIGN : ':';

terminal ANONYMOUS_PREFIX : '::';

terminal AS: 'as';

terminal IF: 'if';

terminal THEN: 'then';

terminal ELSEIF: 'elseif';

terminal ELSE: 'else';

terminal WITH: 'withCategories';

terminal WHEN: 'when';

terminal TRUE: 'true';

terminal FALSE: 'false';

terminal ORDERED: 'ordered';

terminal STRING:
	'"' (ESCAPE_SEQUENCE | !('\\' | '"'))* '"';

terminal TEXT_BLOCK:
	'<<' -> '>>';

terminal INTEGER returns ecore::EInt:
	('0' | '1'..'9' '0'..'9'*);
	
terminal FLOAT returns ecore::EDouble: 
	'0'..'9' + '.' '0'..'9'* EXPONENT?
    | '.' '0'..'9'+ EXPONENT?
    | '0'..'9'+ EXPONENT
    | ('0'..'9')
    ;

terminal fragment SIGN:
	('+'|'-')
;

terminal fragment ESCAPE_SEQUENCE:
	'\\' ('b' | 't' | 'n' | 'f' | 'r' | '\"' | '\'' | '\\')
	| UNICODE_ESCAPE
	| OCTAL_ESCAPE;

terminal fragment OCTAL_ESCAPE:
	  '\\' ('0'..'3') ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7') ('0'..'7')
	| '\\' ('0'..'7');

terminal fragment UNICODE_ESCAPE:
	'\\' 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT;

terminal fragment HEXDIGIT:
	('0'..'9' | 'a'..'f' | 'A'..'F');

terminal fragment EXPONENT
	: ('e'|'E'|'d'|'D') ('+'|'-')?('0'..'9')+;

terminal SL_COMMENT : ('#') !('\n'|'\r')* ('\r'? '\n')? ;

terminal ML_COMMENT : '/#' -> '#/';

terminal BEGIN: '{';

terminal END: '}' ;

terminal ID: ('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'| '0'..'9')*;

terminal WS: (' '|'\t'|'\r'|'\n')+; 
