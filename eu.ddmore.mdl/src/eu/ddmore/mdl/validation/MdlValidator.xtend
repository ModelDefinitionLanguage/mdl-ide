/*
 * generated by Xtext
 */
package eu.ddmore.mdl.validation

import eu.ddmore.mdl.mdl.MclObject
import eu.ddmore.mdl.mdl.MdlPackage
import org.eclipse.xtext.validation.Check
import java.util.HashSet
import eu.ddmore.mdl.mdl.BlockStatement

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class MdlValidator extends AbstractMdlValidator {
	val static MDLOBJ = 'mdlobj'
	val static DATAOBJ = 'dataobj'
	val static TASKOBJ = 'taskobj'
	val static PARAMOBJ = 'paramobj'

	public static val UNKNOWN_BLOCK = "eu.ddmore.mdl.validation.UnknownBlock"
	public static val WRONG_SUBBLOCK = "eu.ddmore.mdl.validation.WrongSubBlock"
	public static val WRONG_PARENT_BLOCK = "eu.ddmore.mdl.validation.WrongParentBlock"
	public static val MANDATORY_BLOCK_MISSING = "eu.ddmore.mdl.validation.MandatoryBlockMissing"


	val static BlkData = #{
		"COVARIATES" -> false, "VARIABILITY_LEVELS" -> true, "STRUCTURAL_PARAMETERS" -> false,
		"VARIABILITY_PARAMETERS" -> false, "RANDOM_VARIABLE_DEFINITION" -> false,
		"INDIVIDUAL_VARIABLES" -> false, "MODEL_PREDICTION" -> false,
		"OBSERVATION" -> false, "GROUP_VARIABLES" -> false
	}

	val static SubBlkData = #{
		"DEQ" -> "MODEL_PREDICTION", "COMPARTMENT" -> "MODEL_PREDICTION"
	}

	@Check
	def validateMclObjects(MclObject mclObject){
		switch(mclObject.mdlObjType){
			case MDLOBJ: mclObject.validateMdlObject
		}
	}
	
	def validateMdlObject(MclObject it){
		validateMdlObjectHasCorrectBlocks
	}
	
	
//	def validateMdlObjArguments(MclObject it){
//		blkArgs.args.forEach[  ]
//	}
	
	def validateMdlObjectHasCorrectBlocks(MclObject it){
		// map of just the mandatory blocks
		val mandatoryBlock = new HashSet<String>(BlkData.filter[blk, mand|mand == true].keySet)
		for(blk : blocks){
			// remove mandatory block if it exists
			mandatoryBlock.remove(blk.identifier)
		}
		// check if mandatory blocks missing
		mandatoryBlock.forEach[blk, mand| error("mandatory block '" + blk + "' is missing in mdlobj '" + name + "'",
					MdlPackage.eINSTANCE.mclObject_Blocks, MANDATORY_BLOCK_MISSING, blk) ]
	}

	@Check
	def validateMdlObjBlocks(BlockStatement it){
		if(eContainer instanceof MclObject){
			val mdlObj = eContainer as MclObject
			if(mdlObj.mdlObjType == MDLOBJ){
				if(!BlkData.containsKey(identifier)){
					error("block '" + identifier + "' cannot be used in a mdlobj",
						MdlPackage.eINSTANCE.blockStatement_Identifier, UNKNOWN_BLOCK, identifier)
				}
			}
		}
		if (eContainer instanceof BlockStatement) {
			val blkStatement = eContainer as BlockStatement
			if (!SubBlkData.containsKey(identifier)) {
				error("block '" + identifier + "' cannot be used as a sub-block",
					MdlPackage.eINSTANCE.blockStatement_Identifier, WRONG_SUBBLOCK,
					identifier)
			} else if (SubBlkData.get(identifier) != blkStatement.identifier) {
				// recognised sub-block but in the wrong place
				error("sub-block '" + identifier + "' cannot be used in the '" + blkStatement.identifier + "' block",
						MdlPackage.eINSTANCE.blockStatement_Identifier,
						WRONG_PARENT_BLOCK, identifier)

			}
		}
	}

}
